<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NFL Sim — Sim Season (Headless)</title>
<style>
:root{--bg:#0b1220;--panel:#121a2a;--card:#0e1630;--text:#eef2ff;--muted:#93a0b1;--accent:#5eead4;--home:#4ade80;--away:#60a5fa}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:grid;place-items:center}
main{width:min(1000px,95vw);display:grid;gap:16px}
h1{margin:0 0 6px;font-size:22px;letter-spacing:.2px}
.panel{background:var(--panel);border-radius:14px;padding:12px;border:1px solid #1c2440;box-shadow:0 6px 24px rgba(0,0,0,.25)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
.btn{display:inline-flex;align-items:center;justify-content:center;padding:10px 12px;border-radius:10px;background:var(--accent);color:#0a0f17;font-weight:700;font-size:14px;border:none;box-shadow:0 2px 0 rgba(0,0,0,.25);text-decoration:none;cursor:pointer}
.btn.ghost{background:var(--card);color:#dbe3ef;border:1px solid #2a355a;box-shadow:none;text-decoration:none}
.small{font-size:12px;color:var(--muted)}
hr{height:1px;background:#1c2440;border:0;margin:6px 0;border-radius:2px}
.table{width:100%;border-collapse:collapse;font-size:13px}
.table th,.table td{border-bottom:1px solid #1f2740;padding:8px 8px;text-align:left}
.table th{font-weight:700;color:#dbe3ef}
.right{text-align:right}
.grid{display:grid;grid-template-columns:1.3fr .7fr;gap:12px}
.section{background:rgba(255,255,255,.02);border:1px solid #1c2440;border-radius:12px;padding:8px}
.section h3{margin:0 0 6px;font-size:14px}
.pill{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--card);border:1px solid #233055;font-size:12px;color:var(--muted)}
code{background:#0e1630;padding:2px 6px;border-radius:8px;border:1px solid #2a355a}
</style>
</head>
<body>
  <main>
    <div class="row">
      <h1>Sim Season (Headless)</h1>
      <div class="row" style="gap:8px">
        <a id="toIndex" class="btn ghost">Weekly Games</a>
        <a id="toStandings" class="btn ghost">Standings</a>
        <a id="toSchedule" class="btn">Schedule</a>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <div class="row" style="gap:8px">
          <button class="btn" id="runBtn">▶ Run Season</button>
          <button class="btn ghost" id="dlResultsBtn" disabled>Download Results CSV</button>
          <button class="btn ghost" id="dlStandBtn" disabled>Download Standings CSV</button>
        </div>
        <div class="row" style="gap:8px">
          <span class="pill" id="schedPill">Schedule: loading…</span>
          <span class="pill" id="teamsPill">Teams: —</span>
          <span class="pill" id="progressPill">Progress: —</span>
          <span class="pill" id="seasonPill">Season: —</span>
        </div>
      </div>
      <hr>
      <div class="grid">
        <div class="section">
          <h3>Results (by Week)</h3>
          <div id="results"></div>
        </div>
        <div class="section">
          <h3>Standings</h3>
          <div id="standings"></div>
        </div>
      </div>
    </div>

    <div class="small">
      Uses roster ratings from <code>players.csv</code> and games from <code>schedule.csv</code>.
      If your <code>engine.js</code> exposes <code>window.runGameHeadless(home, away, playersUrl)</code>,
      this page will use it automatically.
    </div>
  </main>

<!-- prefer your real engine when available -->
<script src="engine.js"></script>
<script>
/* ===== Params & nav ===== */
const PARAMS = new URLSearchParams(location.search);
const RAW_PLAYERS_PARAM  = (PARAMS.get('players')  || '').replace('/refs/heads/', '/');
const RAW_SCHEDULE_PARAM = (PARAMS.get('schedule') || '').replace('/refs/heads/', '/');
const SELECTED_SEASON    = +(PARAMS.get('season') || 2020) || 2020;

function y2(y){ return String((y+1)%100).padStart(2,'0'); }
function buildQS(season){
  const p = RAW_PLAYERS_PARAM ? `players=${encodeURIComponent(RAW_PLAYERS_PARAM)}` : '';
  const s = RAW_SCHEDULE_PARAM? `schedule=${encodeURIComponent(RAW_SCHEDULE_PARAM)}`: '';
  const y = season ? `season=${season}` : '';
  const parts = [p,s,y].filter(Boolean);
  return parts.length?`?${parts.join('&')}`:'';
}

document.getElementById('toIndex').href     = `index.html${buildQS(SELECTED_SEASON)}`;
document.getElementById('toStandings').href = `standings.html${buildQS(SELECTED_SEASON)}`;
document.getElementById('toSchedule').href  = `schedule.html${buildQS(SELECTED_SEASON)}`;
document.getElementById('seasonPill').textContent = `Season: ${SELECTED_SEASON}–${y2(SELECTED_SEASON)}`;

/* ===== Data sources ===== */
const PLAYERS_URLS = RAW_PLAYERS_PARAM
  ? [RAW_PLAYERS_PARAM, new URL('players.csv', location.href).href,
     'https://raw.githubusercontent.com/aaronwolk00/game_sim/refs/heads/main/players.csv']
  : [new URL('players.csv', location.href).href,
     'https://raw.githubusercontent.com/aaronwolk00/game_sim/refs/heads/main/players.csv'];

const SCHEDULE_URLS = RAW_SCHEDULE_PARAM
  ? [RAW_SCHEDULE_PARAM, new URL('schedule.csv', location.href).href]
  : [new URL('schedule.csv', location.href).href];

const schedPill = document.getElementById('schedPill');
const teamsPill = document.getElementById('teamsPill');
const progressPill = document.getElementById('progressPill');
const resultsEl = document.getElementById('results');
const standingsEl = document.getElementById('standings');
const runBtn = document.getElementById('runBtn');
const dlResultsBtn = document.getElementById('dlResultsBtn');
const dlStandBtn = document.getElementById('dlStandBtn');

/* ===== Season window (dynamic from selected season) ===== */
const SEASON_START = new Date(`${SELECTED_SEASON}-09-01T00:00:00-04:00`);
const SEASON_END   = new Date(`${SELECTED_SEASON+1}-02-15T00:00:00-05:00`);

/* ===== Live channel (per-season) ===== */
const LIVE_KEY_RESULTS   = `simSeason:${SELECTED_SEASON}:results`;
const LIVE_KEY_STANDINGS = `simSeason:${SELECTED_SEASON}:standings`;
const chan = new BroadcastChannel(`nfl-sim-${SELECTED_SEASON}`);
function broadcast(payload){ try{ chan.postMessage(payload); }catch(e){} }

/* ===== CSV helpers ===== */
async function fetchCsvFrom(urls){
  let lastErr=null;
  for(const url of urls){
    try{
      const res = await fetch(url, { cache:'no-store', mode:'cors' });
      if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return { text: await res.text(), url };
    }catch(e){ lastErr=e; }
  }
  throw lastErr || new Error('CSV not reachable');
}
function parseCsvToRows(text){
  text = String(text||'').replace(/^\uFEFF/,'');
  const rows=[]; let row=[], field='', q=false;
  for(let i=0;i<text.length;i++){
    const c=text[i];
    if(q){
      if(c==='"'){ if(text[i+1]==='"'){ field+='"'; i++; } else q=false; }
      else field+=c;
    }else{
      if(c==='"') q=true;
      else if(c===','){ row.push(field); field=''; }
      else if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; }
      else if(c!=='\r'){ field+=c; }
    }
  }
  row.push(field); rows.push(row);
  while(rows.length && rows[rows.length-1].every(x => String(x||'').trim()==='')) rows.pop();
  return rows.filter(r=>r.length && r.some(x=>String(x||'').trim()!==''));;
}
function detectHeaderIndex(rows){
  const wantSets=[['week','home','away'],['week','team','opp']];
  const norm=s=>String(s||'').trim().toLowerCase();
  for(let i=0;i<Math.min(rows.length,12);i++){
    const set=new Set(rows[i].map(norm));
    for(const wants of wantSets){ if(wants.every(w=>set.has(w))) return i; }
  }
  return 0;
}
function rowsToObjects(rows, headerIdx){
  const header = rows[headerIdx].map(h => String(h||'').trim());
  return rows.slice(headerIdx+1).map(r => {
    const o={}; header.forEach((h,j)=> o[h]= r[j]===undefined ? '' : r[j]); return o;
  });
}

/* ===== Players → team ratings ===== */
function toNum(x, d=70){ const v=Number(x); return Number.isFinite(v) ? v : d; }
function playerOVR(p){
  if (p.OVR !== undefined && p.OVR !== '') return toNum(p.OVR, 70);
  const keys = ['SPD','STR','AGI','INT','TEC','HANDS','TACK','BLOCK','COVER','PASS_ACC','PASS_PWR'];
  let sum=0, n=0;
  keys.forEach(k => { const v = toNum(p[k], NaN); if (Number.isFinite(v)){ sum+=v; n++; } });
  return n? (sum/n) : 70;
}
function buildRatings(players){
  const byTeam = new Map();
  players.forEach(p=>{
    const team = String(p.Team||'').trim();
    if(!team) return;
    if(!byTeam.has(team)) byTeam.set(team, []);
    byTeam.get(team).push(p);
  });
  const ratings = {};
  Array.from(byTeam.entries()).forEach(([team, list])=>{
    const vals = list.map(playerOVR);
    ratings[team] = Math.round(vals.reduce((a,b)=>a+b,0)/vals.length);
  });
  return ratings;
}

/* ===== Schedule mapping (handles both styles) ===== */
const SEASON_TYPE_ORDER = { PRE:0, REG:1, POST:2, '':1 };
const norm = s => String(s||'').trim();
function pick(obj, keys){
  for(const k of keys){ if (obj[k] !== undefined && String(obj[k]).trim()!=='') return obj[k]; }
  return '';
}
function toInt(x, d=0){ const n = parseInt(String(x||'').replace(/[^\d\-]/g,''), 10); return Number.isFinite(n) ? n : d; }
function parseGameDate(ds, ts){
  const d = String(ds||'').trim(), t = String(ts||'').trim();
  if(!d) return null;
  let out = t ? new Date(`${d} ${t} ET`) : new Date(d);
  if(!out || isNaN(out)){
    const m = d.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
    if(m){
      let [_, mm, dd, yy] = m; let year = +yy; if(year<100) year += 2000;
      out = new Date(year, +mm-1, +dd, 13, 0, 0);
    } else out=null;
  }
  return out;
}
function mapDirectRow(r){
  const season = toInt(pick(r, ['season','Season']));
  const season_type = String(pick(r, ['season_type','game_type','SeasonType'])).toUpperCase() || 'REG';
  const week = toInt(pick(r, ['week','Week','Wk']), 0);
  const date = pick(r, ['date','gameday','game_date','Date']);
  const time = pick(r, ['time','game_time_eastern','kickoff','Time']);
  const venue= pick(r, ['venue','site','stadium','Stadium','Site']);
  const home = norm(pick(r, ['home_team','Home','home','Home Team','HomeTeam','team_home','team_home_name']));
  const away = norm(pick(r, ['away_team','Away','away','Away Team','AwayTeam','team_away','team_away_name']));
  return { season, season_type, week, date, time, venue, home, away };
}
/* Build home/away games from team/opp/home_away rows */
function buildFromTeamOpp(objs){
  const getHA=r=>{const s=String(r.home_away||r.homeaway||r.ha||'').trim().toUpperCase();
    if(['H','HOME','1','TRUE'].includes(s)) return 'H';
    if(['A','AWAY','@','0','FALSE'].includes(s)) return 'A';
    return '';};
  const keyFor=r=>{
    const rid=String(r.row_id||'').trim();
    const gid=String(r.game_id||'').trim()||(rid.includes(':')?rid.split(':')[0]:'');
    if(gid) return gid;
    const season=r.season||''; const wk=r.week||''; const date=r.date||'';
    const t=(r.team||'').trim(); const o=(r.opp||'').trim();
    return `${season}|${wk}|${date}|${[t,o].sort().join('@')}`;
  };
  const byKey=new Map();
  for(const r of objs){
    const team=String(r.team||'').trim(), opp=String(r.opp||'').trim();
    if(!team||!opp) continue; const k=keyFor(r);
    if(!byKey.has(k)) byKey.set(k,[]); byKey.get(k).push(r);
  }
  const out=[];
  for(const rows of byKey.values()){
    const r0=rows[0];
    const week=toInt(r0.week||r0.Week,0);
    const date=String(r0.date||r0.Date||'').trim();
    const time=String(r0.game_time_eastern||r0.time||'').trim();
    const venue=String(r0.venue||r0.site||r0.Stadium||'').trim();
    const season=toInt(r0.season||r0.Season,0) || (String(date).slice(0,4)|0);
    const season_type=String(r0.season_type||r0.Season_Type||'').toUpperCase()||'REG';

    let home='',away='';
    const h=rows.find(rr=>getHA(rr)==='H'); const a=rows.find(rr=>getHA(rr)==='A');
    if(h){ home=String(h.team).trim(); away=String(h.opp).trim(); }
    else if(rows.length===1){ const rr=r0; const ha=getHA(rr); if(ha==='H'){home=String(rr.team).trim(); away=String(rr.opp).trim();} else {home=String(rr.opp).trim(); away=String(rr.team).trim();}}
    else { const A=rows[0],B=rows[1]; home=String(A.team).trim(); away=String(A.opp||B.team).trim(); }

    if(home&&away) out.push({season, season_type, week, home, away, date, time, venue});
  }
  return out;
}
function inSelectedSeason(g){
  if (Number.isFinite(g.season)) {
    return (g.season === SELECTED_SEASON) && (g.season_type==='REG' || g.season_type==='POST');
  }
  const d = parseGameDate(g.date, g.time);
  return !!(d && d >= SEASON_START && d < SEASON_END);
}

/* ===== Team name resolver (schedule → players.csv labels) ===== */
let TEAM_KEYS = []; // filled from ratings
const ALIASES = {
  ARI:'Cardinals', ATL:'Falcons', BAL:'Ravens', BUF:'Bills', CAR:'Panthers', CHI:'Bears', CIN:'Bengals', CLE:'Browns',
  DAL:'Cowboys', DEN:'Broncos', DET:'Lions', GB:'Packers', HOU:'Texans', IND:'Colts', JAX:'Jaguars', JAC:'Jaguars',
  KC:'Chiefs', LAC:'Chargers', LAR:'Rams', LV:'Raiders', OAK:'Raiders', STL:'Rams',
  MIA:'Dolphins', MIN:'Vikings', NE:'Patriots', NO:'Saints', NYG:'Giants', NYJ:'Jets',
  PHI:'Eagles', PIT:'Steelers', SEA:'Seahawks', SF:'49ers', TB:'Buccaneers', TEN:'Titans',
  WAS:'Commanders', WFT:'Commanders', REDSKINS:'Commanders', 'WASHINGTON FOOTBALL TEAM':'Commanders'
};
function sNorm(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9]/g,''); }
function resolveTeamName(name){
  if(!name) return '';
  if (TEAM_KEYS.includes(name)) return name;
  const n = sNorm(name);
  for(const k of TEAM_KEYS){ if(sNorm(k)===n) return k; }
  for(const k of TEAM_KEYS){ if(sNorm(k).includes(n) || n.includes(sNorm(k))) return k; }
  const alias = ALIASES[name.toUpperCase()];
  if(alias){
    const al = sNorm(alias);
    for(const k of TEAM_KEYS){ if(sNorm(k).includes(al) || al.includes(sNorm(k))) return k; }
  }
  return name;
}

/* ===== QuickSim fallback (used if engine doesn't provide runGameHeadless) ===== */
async function quickSimGame(home, away, ratings){
  const rh = ratings[home] ?? 70, ra = ratings[away] ?? 70;
  const delta = (rh - ra) / 30;
  const drivesPerTeam = 12 + Math.round((Math.random()-0.5)*2);
  const cfg = (adv)=>( { pTD: 0.23 + 0.09*adv, pFG: 0.17 + 0.04*adv, xp:0.94 } );
  const H=cfg(+delta), A=cfg(-delta);
  function simSide(c){ let pts=0; for(let i=0;i<drivesPerTeam;i++){ const r=Math.random();
    if(r<c.pTD){ pts+=6; if(Math.random()<c.xp) pts+=1; } else if(r<c.pTD+c.pFG){ pts+=3; } } return pts; }
  let homePts=simSide(H), awayPts=simSide(A);
  if(Math.abs(homePts-awayPts)<=2){ if(Math.random()<0.35){ (homePts<=awayPts)?(homePts+=3):(awayPts+=3); } }
  if(homePts===awayPts){
    homePts += Math.random()<H.pTD?7:(Math.random()<H.pFG?3:0);
    awayPts += Math.random()<A.pTD?7:(Math.random()<A.pFG?3:0);
    if(homePts===awayPts){ (Math.random()<0.5)?(homePts+=3):(awayPts+=3); }
  }
  return { homePts, awayPts };
}
async function simulateGame(home, away, playersUrl, ratings){
  if (typeof window.runGameHeadless === 'function') {
    return await window.runGameHeadless(home, away, playersUrl); // must return {homePts, awayPts}
  }
  return quickSimGame(home, away, ratings);
}

/* ===== Render helpers ===== */
function resultsHTML(byWeek){
  const weeks = Array.from(byWeek.keys()).sort((a,b)=>a-b);
  return weeks.map(w=>{
    const list = byWeek.get(w);
    return `
      <div class="section" style="margin-bottom:8px">
        <h3>Week ${w}</h3>
        <table class="table">
          <thead><tr><th>Matchup</th><th class="right">Score</th></tr></thead>
          <tbody>
            ${list.map(g=>`
              <tr>
                <td>${g.away} @ ${g.home}</td>
                <td class="right">${g.awayPts}-${g.homePts} (${g.winner})</td>
              </tr>`).join('')}
          </tbody>
        </table>
      </div>`;
  }).join('');
}
function standingsHTML(stand){
  const rows = Object.values(stand).sort((a,b)=> (b.wins-a.wins) || ((b.pf-b.pa)-(a.pf-a.pa)) || a.team.localeCompare(b.team));
  return `
    <table class="table">
      <thead><tr><th>#</th><th>Team</th><th class="right">W</th><th class="right">L</th><th class="right">PF</th><th class="right">PA</th><th class="right">Diff</th></tr></thead>
      <tbody>
        ${rows.map((r,i)=>`
          <tr>
            <td class="right">${i+1}</td><td>${r.team}</td>
            <td class="right">${r.wins}</td><td class="right">${r.losses}</td>
            <td class="right">${r.pf}</td><td class="right">${r.pa}</td>
            <td class="right">${r.pf - r.pa}</td>
          </tr>`).join('')}
      </tbody>
    </table>`;
}

/* ===== CSV download ===== */
function downloadCsv(filename, rows){
  if (!rows.length) return;
  const header = Object.keys(rows[0]).join(',');
  const lines = rows.map(r => Object.values(r).map(v=>{
    const s=String(v??''); return (/[",\n]/.test(s)) ? `"${s.replace(/"/g,'""')}"` : s;
  }).join(','));
  const csv = [header, ...lines].join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 800);
}

/* ===== Boot & Run ===== */
let RATINGS = {};
let SCHEDULE = [];
let PLAYERS_URL_USED = '';

(async function init(){
  try{
    // players → ratings
    const { text: playersText, url: playersUrlUsed } = await fetchCsvFrom(PLAYERS_URLS);
    PLAYERS_URL_USED = playersUrlUsed;

    const prow = parseCsvToRows(playersText);
    const phi  = 0; // player CSV always has headers in row 0
    const pobjs= rowsToObjects(prow, phi);
    RATINGS = buildRatings(pobjs);
    TEAM_KEYS = Object.keys(RATINGS);
    teamsPill.textContent = `Teams: ${TEAM_KEYS.length}`;

    // schedule
    const { text: schedText } = await fetchCsvFrom(SCHEDULE_URLS);
    const srow = parseCsvToRows(schedText);
    const shi  = detectHeaderIndex(srow);
    const sobjs= rowsToObjects(srow, shi);

    // choose mapper by headers
    const headers = srow[shi].map(h=>String(h||'').trim().toLowerCase());
    const mapped = (headers.includes('team') && headers.includes('opp'))
      ? buildFromTeamOpp(sobjs)
      : sobjs.map(mapDirectRow).filter(g => g.home && g.away);

    // season filter + normalize team names
    let filtered = mapped.filter(inSelectedSeason).map(g=>{
      const home = resolveTeamName(g.home);
      const away = resolveTeamName(g.away);
      return { ...g, home, away };
    });

    // if nothing matched the season tag, fall back to all rows but still resolve teams
    if (filtered.length === 0){
      filtered = mapped.map(g=>({ ...g, home:resolveTeamName(g.home), away:resolveTeamName(g.away) }));
      schedPill.textContent = `Schedule: ${filtered.length} games (unfiltered)`;
    } else {
      schedPill.textContent = `Schedule: ${filtered.length} games (${SELECTED_SEASON} REG/POST)`;
    }

    // sort
    SCHEDULE = filtered.sort((a,b)=>{
      const aST = SEASON_TYPE_ORDER[a.season_type] ?? 1;
      const bST = SEASON_TYPE_ORDER[b.season_type] ?? 1;
      const ad  = parseGameDate(a.date, a.time)?.getTime() || 0;
      const bd  = parseGameDate(b.date, b.time)?.getTime() || 0;
      return (aST - bST) || (a.week - b.week) || (ad - bd) || (a.away+a.home).localeCompare(b.away+b.home);
    });

    if (!SCHEDULE.length){
      resultsEl.innerHTML = `<div class="small" style="color:#fca5a5">No valid games found for season ${SELECTED_SEASON}. Check <code>schedule.csv</code> headers.</div>`;
      runBtn.disabled = true;
    }
  }catch(e){
    console.error(e);
    schedPill.textContent = 'Schedule: error';
    resultsEl.innerHTML = `<div class="small" style="color:#fca5a5">Could not load <code>players.csv</code> and/or <code>schedule.csv</code>.</div>`;
  }
})();

runBtn.addEventListener('click', async ()=>{
  runBtn.disabled = true;
  resultsEl.innerHTML = '';
  standingsEl.innerHTML = '';

  // reset live state
  localStorage.removeItem(LIVE_KEY_RESULTS);
  localStorage.removeItem(LIVE_KEY_STANDINGS);
  broadcast({ type:'reset' });

  const standings = {};
  function ensureTeam(t){ if(!standings[t]) standings[t] = { team:t, wins:0, losses:0, pf:0, pa:0 }; }

  // pre-seed all teams (handles bye weeks)
  const uniqTeams = new Set();
  SCHEDULE.forEach(g => { uniqTeams.add(g.home); uniqTeams.add(g.away); });
  Array.from(uniqTeams).forEach(ensureTeam);

  const byWeek = new Map();
  const resultsRows = [];

  let done=0, total=SCHEDULE.length;
  progressPill.textContent = `Progress: 0/${total}`;
  broadcast({ type:'standings', standings, progress:{done,total} });

  for(const g of SCHEDULE){
    ensureTeam(g.home); ensureTeam(g.away);

    const { homePts, awayPts } = await simulateGame(g.home, g.away, PLAYERS_URL_USED, RATINGS);
    const winner = homePts>awayPts ? g.home : g.away;

    standings[g.home].pf += homePts; standings[g.home].pa += awayPts;
    standings[g.away].pf += awayPts; standings[g.away].pa += homePts;
    if(winner===g.home){ standings[g.home].wins++; standings[g.away].losses++; }
    else { standings[g.away].wins++; standings[g.home].losses++; }

    const rec = { Season:SELECTED_SEASON, Type:g.season_type||'REG', Week:g.week, Date:g.date, Time:g.time,
                  Away:g.away, Home:g.home, AwayScore:awayPts, HomeScore:homePts, Winner:winner };
    resultsRows.push(rec);

    if(!byWeek.has(g.week)) byWeek.set(g.week, []);
    byWeek.get(g.week).push({ ...g, homePts, awayPts, winner });

    done++; progressPill.textContent = `Progress: ${done}/${total}`;

    try{
      localStorage.setItem(LIVE_KEY_RESULTS, JSON.stringify(resultsRows));
      localStorage.setItem(LIVE_KEY_STANDINGS, JSON.stringify(standings));
    }catch(e){}
    broadcast({ type:'standings', standings, progress:{done,total}, lastGame:rec });

    await new Promise(r=>setTimeout(r, 0)); // yield
  }

  resultsEl.innerHTML = resultsHTML(byWeek);
  standingsEl.innerHTML = standingsHTML(standings);

  dlResultsBtn.disabled = false;
  dlStandBtn.disabled = false;

  const fileTag = `${SELECTED_SEASON}-${y2(SELECTED_SEASON)}`;
  dlResultsBtn.onclick = ()=> downloadCsv(`season_results_${fileTag}.csv`, resultsRows);
  dlStandBtn.onclick   = ()=> downloadCsv(`season_standings_${fileTag}.csv`,
    Object.values(standings).sort((a,b)=> (b.wins-a.wins)||((b.pf-b.pa)-(a.pf-a.pa))||a.team.localeCompare(b.team))
  );

  broadcast({ type:'complete', standings });
});
</script>
</body>
</html>

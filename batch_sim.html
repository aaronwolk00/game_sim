<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NFL Sim — Batch Simulator</title>
<style>
  :root{
    --bg:#0b1220;--panel:#121a2a;--card:#0e1630;--text:#eef2ff;--muted:#93a0b1;--accent:#5eead4;
    --ok:#4ade80;--warn:#f59e0b;--bad:#f87171;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--text);
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    display:flex;flex-direction:column;align-items:center;gap:14px;padding:18px;
  }
  main{width:min(1100px,96vw);display:grid;gap:16px}
  h1{margin:0;font-size:22px;letter-spacing:.2px}
  .panel{background:var(--panel);border-radius:14px;padding:14px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  label{font-size:12px;color:var(--muted)}
  input,select,button{
    background:var(--card);color:var(--text);border:1px solid #1e2a43;
    border-radius:10px;padding:8px 10px;font-size:14px
  }
  input[type="number"]{width:110px}
  button{cursor:pointer}
  button.primary{background:var(--accent);color:#0b1220;border-color:transparent;font-weight:600}
  .grid{display:grid;gap:12px}
  .two{grid-template-columns:1fr 1fr}
  .three{grid-template-columns:repeat(3,1fr)}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{padding:8px;border-bottom:1px solid #1e2a43;text-align:left}
  th{color:var(--muted);font-weight:600}
  .muted{color:var(--muted)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#1b2640;color:var(--muted);font-size:12px}
  progress{width:100%;height:12px}
  .small{font-size:12px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .warn{color:var(--warn)}
  .ok{color:var(--ok)}
</style>
</head>
<body>
  <main>
    <header class="panel">
      <h1>Batch Simulator</h1>
      <div class="muted small">Run many games and summarize realistic ranges for scores, yards, plays, drives, etc. Uses your current engine &amp; roster CSV.</div>
    </header>

    <section class="panel grid">
      <div class="row">
        <label>Players CSV URL</label>
        <input id="playersUrl" class="mono" placeholder="raw.githubusercontent.com/.../layer3_rosters.csv" />
      </div>
      <div class="row">
        <label># Games (n)</label>
        <input id="numGames" type="number" min="1" max="10000" step="1" value="500" />
        <label>Home (teamId optional)</label>
        <input id="homeTeam" placeholder="e.g., IND" />
        <label>Away (teamId optional)</label>
        <input id="awayTeam" placeholder="e.g., CAR" />
        <label>Seed (optional)</label>
        <input id="seed" type="number" placeholder="e.g., 123" />
        <label>Keep PBP</label>
        <select id="keepPBP">
          <option value="0" selected>No (faster)</option>
          <option value="1">Yes</option>
        </select>
      </div>
      <div class="row">
        <button id="btnLoad" class="primary">Load Teams</button>
        <button id="btnRun">Run Batch</button>
        <button id="btnCSV">Download per-game CSV</button>
        <span id="status" class="pill">Idle</span>
      </div>
      <progress id="prog" max="1" value="0"></progress>
      <div id="notes" class="small muted"></div>
    </section>

    <section class="panel">
      <h3 style="margin:0 0 10px">Aggregates (per game)</h3>
      <table id="aggTable">
        <thead>
          <tr>
            <th>Metric</th><th>Avg</th><th>Std</th><th>Min</th><th>Max</th><th class="muted">Notes</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="small muted" id="aggMeta"></div>
    </section>

    <section class="panel">
      <h3 style="margin:0 0 10px">Per-side &amp; composition</h3>
      <table id="sideTable">
        <thead>
          <tr>
            <th>Metric</th><th>Home Avg</th><th>Away Avg</th><th class="muted">Notes</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <section class="panel">
      <h3 style="margin:0 0 10px">Scoring breakdown (per game)</h3>
      <table id="scoreTable">
        <thead>
          <tr>
            <th>Type</th><th>Avg Count</th><th class="muted">How counted</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </main>

  <script type="module">
    import { loadLeague } from './data_models.js';
    import { simulateGame } from './game_engine.js';

    // ---------- URL params ----------
    const P = new URLSearchParams(location.search);
    const defaultCSV = 'https://raw.githubusercontent.com/aaronwolk00/game_sim/refs/heads/main/layer3_rosters.csv';
    const csvParam = (P.get('players') || '').replace('/refs/heads/', '/');  // tolerate refs/heads form
    const playersURL = csvParam || defaultCSV;

    const nParam = +(P.get('n') || 500);
    const homeParam = P.get('home') || '';
    const awayParam = P.get('away') || '';
    const seedParam = P.get('seed'); // may be null

    // ---------- DOM ----------
    const el = (id)=>document.getElementById(id);
    el('playersUrl').value = playersURL;
    el('numGames').value = nParam;
    if (homeParam) el('homeTeam').value = homeParam;
    if (awayParam) el('awayTeam').value = awayParam;
    if (seedParam!=null) el('seed').value = seedParam;

    const status = el('status');
    const prog = el('prog');
    const notes = el('notes');
    const aggBody = document.querySelector('#aggTable tbody');
    const aggMeta = el('aggMeta');
    const sideBody = document.querySelector('#sideTable tbody');
    const scoreBody = document.querySelector('#scoreTable tbody');

    function setStatus(text){ status.textContent = text; }
    function setNote(text){ notes.textContent = text; }

    // ---------- Stats helpers ----------
    class Stat {
      constructor(){
        this.n = 0;
        this.mean = 0;
        this.M2 = 0;
        this.min = Infinity;
        this.max = -Infinity;
      }
      push(x){
        const v = Number.isFinite(x) ? x : 0;
        this.n++;
        const delta = v - this.mean;
        this.mean += delta / this.n;
        this.M2 += delta * (v - this.mean);
        if (v < this.min) this.min = v;
        if (v > this.max) this.max = v;
      }
      std(){
        return this.n > 1 ? Math.sqrt(this.M2 / (this.n - 1)) : 0;
      }
      toRow(fmt=(v)=>v.toFixed(2), notes=''){
        return [fmt(this.mean), fmt(this.std()), fmt(this.min), fmt(this.max), notes];
      }
    }

    function makeBuckets(){
      return {
        // overall per-game
        totalPts: new Stat(),
        totalYards: new Stat(),
        rushYds: new Stat(),
        passYds: new Stat(),
        plays: new Stat(),
        drives: new Stat(),
        turnovers: new Stat(),
        ypp: new Stat(),
        avgDriveSec: new Stat(),
        playsPerDrive: new Stat(),
        // scoring counts
        td: new Stat(),
        fgMade: new Stat(),
        fgAtt: new Stat(),
        safety: new Stat(),
        // per side
        homePts: new Stat(), awayPts: new Stat(),
        homeYards: new Stat(), awayYards: new Stat(),
        homePlays: new Stat(), awayPlays: new Stat(),
        homeTOPsec: new Stat(), awayTOPsec: new Stat(),
        homeRush: new Stat(), awayRush: new Stat(),
        homePass: new Stat(), awayPass: new Stat(),
        // per-game CSV rows
        perGameRows: []
      };
    }

    // ---------- League loading ----------
    let TEAMS = [];
    let TEAM_BY_ID = new Map();

    async function loadTeams(){
      setStatus('Loading rosters…');
      const url = (el('playersUrl').value || '').trim();
      if (!url) throw new Error('Players CSV URL required');
      const league = await loadLeague(url);
      TEAMS = league.teams || league || [];
      TEAM_BY_ID = new Map(
        TEAMS.map(t => [String(t.teamId || t.id || t.name).trim(), t])
      );
      setStatus(`Loaded ${TEAMS.length} teams`);
      setNote('Use teamIds (as in your CSV) for home/away, or leave blank to randomize each trial.');
    }

    // ---------- Random helpers ----------
    function pickRandomTeam(){
      return TEAMS[Math.floor(Math.random() * TEAMS.length)];
    }

    function resolveTeam(tag){
      if (!tag) return null;
      const key = String(tag).trim();
      const exact = TEAM_BY_ID.get(key);
      if (exact) return exact;
      const lc = key.toLowerCase();
      return TEAMS.find(
        t => String(t.teamName || t.name || t.teamId).toLowerCase() === lc
      ) || null;
    }

    // ---------- Per-game extraction ----------
    function summarizeGame(result){
      const home = result.teamStats?.home || {plays:0,yardsTotal:0,rushYards:0,passYards:0,turnovers:0};
      const away = result.teamStats?.away || {plays:0,yardsTotal:0,rushYards:0,passYards:0,turnovers:0};

      const homePts = result.score.home;
      const awayPts = result.score.away;
      const pts   = homePts + awayPts;
      const yards = (home.yardsTotal || 0) + (away.yardsTotal || 0);
      const rush  = (home.rushYards  || 0) + (away.rushYards  || 0);
      const pass  = (home.passYards  || 0) + (away.passYards  || 0);
      const plays = (home.plays      || 0) + (away.plays      || 0);
      const drives = (result.drives || []).length;
      const tovs = (home.turnovers || 0) + (away.turnovers || 0);
      const ypp = plays > 0 ? yards / plays : 0;

      let totalDriveSec = 0;
      let homeTOP = 0, awayTOP = 0;
      for (const d of (result.drives || [])){
        const sec = Number(d.durationSec) || 0;
        totalDriveSec += sec;
        if (d.offense === 'home') homeTOP += sec;
        else if (d.offense === 'away') awayTOP += sec;
      }
      const avgDriveSec = drives > 0 ? totalDriveSec / drives : 0;
      const playsPerDrive = drives > 0 ? plays / drives : 0;

      let fgAtt = 0, fgMade = 0;
      for (const p of (result.plays || [])){
        if (p.fieldGoalAttempt){
          fgAtt++;
          if (p.fieldGoalGood) fgMade++;
        }
      }
      let td = 0, safety = 0;
      for (const e of (result.events || [])){
        if (e.type === 'score'){
          if (e.subtype === 'touchdown') td++;
          if (e.subtype === 'safety') safety++;
        }
      }

      return {
        homePts, awayPts,
        pts, yards, rush, pass, plays, drives, tovs, ypp, avgDriveSec, playsPerDrive,
        homeYards: home.yardsTotal || 0,
        awayYards: away.yardsTotal || 0,
        homePlays: home.plays || 0,
        awayPlays: away.plays || 0,
        homeRush: home.rushYards || 0,
        awayRush: away.rushYards || 0,
        homePass: home.passYards || 0,
        awayPass: away.passYards || 0,
        homeTOP, awayTOP,
        td, fgAtt, fgMade, safety
      };
    }

    // ---------- Globals for last batch ----------
    let LAST_ROWS = null;

    // ---------- Batch run ----------
    async function runBatch(){
      if (!TEAMS.length) await loadTeams();

      const n = Math.max(1, Math.min(10000, +el('numGames').value || 500));
      const keepPBP = el('keepPBP').value === '1';
      const seedBase = el('seed').value !== '' ? +el('seed').value : null;

      const fixedHome = resolveTeam(el('homeTeam').value.trim());
      const fixedAway = resolveTeam(el('awayTeam').value.trim());

      if ((el('homeTeam').value||'').trim() && !fixedHome){
        setNote(`Warning: could not resolve home team "${el('homeTeam').value}"`);
      }
      if ((el('awayTeam').value||'').trim() && !fixedAway){
        setNote(`Warning: could not resolve away team "${el('awayTeam').value}"`);
      }

      prog.max = n;
      prog.value = 0;
      setStatus('Running…');

      const B = makeBuckets();

      for (let i = 0; i < n; i++){
        const home = fixedHome || pickRandomTeam();
        let away  = fixedAway || pickRandomTeam();

        if (!fixedAway && away.teamId === home.teamId){
          away = pickRandomTeam();
        }

        const res = simulateGame(home, away, {
          keepPlayByPlay: keepPBP,
          seed: seedBase != null ? (seedBase + i) : undefined
        });

        const g = summarizeGame(res);

        B.totalPts.push(g.pts);
        B.totalYards.push(g.yards);
        B.rushYds.push(g.rush);
        B.passYds.push(g.pass);
        B.plays.push(g.plays);
        B.drives.push(g.drives);
        B.turnovers.push(g.tovs);
        B.ypp.push(g.ypp);
        B.avgDriveSec.push(g.avgDriveSec);
        B.playsPerDrive.push(g.playsPerDrive);

        B.td.push(g.td);
        B.fgAtt.push(g.fgAtt);
        B.fgMade.push(g.fgMade);
        B.safety.push(g.safety);

        B.homePts.push(g.homePts);
        B.awayPts.push(g.awayPts);
        B.homeYards.push(g.homeYards);
        B.awayYards.push(g.awayYards);
        B.homePlays.push(g.homePlays);
        B.awayPlays.push(g.awayPlays);
        B.homeRush.push(g.homeRush);
        B.awayRush.push(g.awayRush);
        B.homePass.push(g.homePass);
        B.awayPass.push(g.awayPass);
        B.homeTOPsec.push(g.homeTOP);
        B.awayTOPsec.push(g.awayTOP);

        B.perGameRows.push({
          game: i + 1,
          homeId: home.teamId, awayId: away.teamId,
          homePts: g.homePts, awayPts: g.awayPts, totalPts: g.pts,
          yards: g.yards, rush: g.rush, pass: g.pass,
          plays: g.plays, drives: g.drives, turnovers: g.tovs, ypp: g.ypp.toFixed(3),
          avgDriveSec: g.avgDriveSec.toFixed(2), playsPerDrive: g.playsPerDrive.toFixed(2),
          td: g.td, fgAtt: g.fgAtt, fgMade: g.fgMade, safety: g.safety,
          homeYards: g.homeYards, awayYards: g.awayYards,
          homePlays: g.homePlays, awayPlays: g.awayPlays,
          homeRush: g.homeRush, awayRush: g.awayRush,
          homePass: g.homePass, awayPass: g.awayPass,
          homeTOPsec: g.homeTOP.toFixed(2), awayTOPsec: g.awayTOP.toFixed(2)
        });

        if ((i % 25) === 0){
          await new Promise(r => setTimeout(r, 0));
        }
        prog.value = i + 1;
      }

      LAST_ROWS = B.perGameRows;
      renderAggregates(B, n);
      setStatus('Done');
    }

    // ---------- Render ----------
    function rowHTML(c1, arr, note=''){
      const [avg,std,min,max,notes] = arr;
      const safeNotes = note || notes || '';
      return `<tr>
        <td class="mono">${c1}</td>
        <td>${avg}</td><td>${std}</td><td>${min}</td><td>${max}</td>
        <td class="muted small">${safeNotes}</td>
      </tr>`;
    }

    function renderAggregates(B, n){
      const fmt2 = (v)=>Number(v).toFixed(2);
      const rows = [];
      rows.push(rowHTML('Total points', B.totalPts.toRow(fmt2), 'Home+Away'));
      rows.push(rowHTML('Total yards',  B.totalYards.toRow(fmt2)));
      rows.push(rowHTML('Rush yards',   B.rushYds.toRow(fmt2)));
      rows.push(rowHTML('Pass yards',   B.passYds.toRow(fmt2)));
      rows.push(rowHTML('Plays',        B.plays.toRow(fmt2)));
      rows.push(rowHTML('Drives',       B.drives.toRow(fmt2)));
      rows.push(rowHTML('Turnovers',    B.turnovers.toRow(fmt2)));
      rows.push(rowHTML('Yards/play',   B.ypp.toRow(fmt2)));
      rows.push(rowHTML('Avg drive sec',B.avgDriveSec.toRow(fmt2)));
      rows.push(rowHTML('Plays/drive',  B.playsPerDrive.toRow(fmt2)));
      rows.push(rowHTML('FG attempts',  B.fgAtt.toRow(fmt2)));
      rows.push(rowHTML('FG made',      B.fgMade.toRow(fmt2)));
      rows.push(rowHTML('Touchdowns',   B.td.toRow(fmt2)));
      rows.push(rowHTML('Safeties',     B.safety.toRow(fmt2)));
      aggBody.innerHTML = rows.join('');

      const homeTOPavg = B.homeTOPsec.mean;
      const awayTOPavg = B.awayTOPsec.mean;
      aggMeta.textContent =
        `Trials: ${n}. Avg TOP (sec) — Home: ${homeTOPavg.toFixed(1)}, ` +
        `Away: ${awayTOPavg.toFixed(1)}. Combined: ${(homeTOPavg + awayTOPavg).toFixed(1)}.`;

      const side = [];
      side.push(`<tr><td class="mono">Points</td><td>${B.homePts.mean.toFixed(2)}</td><td>${B.awayPts.mean.toFixed(2)}</td><td class="muted small">Per side</td></tr>`);
      side.push(`<tr><td class="mono">Yards</td><td>${B.homeYards.mean.toFixed(2)}</td><td>${B.awayYards.mean.toFixed(2)}</td><td></td></tr>`);
      side.push(`<tr><td class="mono">Plays</td><td>${B.homePlays.mean.toFixed(2)}</td><td>${B.awayPlays.mean.toFixed(2)}</td><td></td></tr>`);
      side.push(`<tr><td class="mono">Rush yards</td><td>${B.homeRush.mean.toFixed(2)}</td><td>${B.awayRush.mean.toFixed(2)}</td><td></td></tr>`);
      side.push(`<tr><td class="mono">Pass yards</td><td>${B.homePass.mean.toFixed(2)}</td><td>${B.awayPass.mean.toFixed(2)}</td><td></td></tr>`);
      side.push(`<tr><td class="mono">Time of possession (sec)</td><td>${homeTOPavg.toFixed(1)}</td><td>${awayTOPavg.toFixed(1)}</td><td></td></tr>`);
      sideBody.innerHTML = side.join('');

      const score = [];
      score.push(`<tr><td class="mono">Touchdowns</td><td>${B.td.mean.toFixed(2)}</td><td class="muted small">From events</td></tr>`);
      score.push(`<tr><td class="mono">FG attempts</td><td>${B.fgAtt.mean.toFixed(2)}</td><td class="muted small">From plays</td></tr>`);
      score.push(`<tr><td class="mono">FG made</td><td>${B.fgMade.mean.toFixed(2)}</td><td class="muted small">From plays</td></tr>`);
      score.push(`<tr><td class="mono">Safeties</td><td>${B.safety.mean.toFixed(2)}</td><td class="muted small">From events</td></tr>`);
      scoreBody.innerHTML = score.join('');
    }

    // ---------- CSV ----------
    function toCSV(rows){
      if (!rows || !rows.length) return '';
      const headers = Object.keys(rows[0]);
      const esc = (v)=>{
        const s = String(v);
        return (s.includes(',') || s.includes('"') || s.includes('\n'))
          ? `"${s.replace(/"/g,'""')}"`
          : s;
      };
      const out = [headers.join(',')];
      for (const r of rows){
        out.push(headers.map(h => esc(r[h] ?? '')).join(','));
      }
      return out.join('\n');
    }

    function downloadCSV(rows, name='batch_sim_results.csv'){
      const csv = toCSV(rows);
      if (!csv){
        setNote('No results to download.');
        return;
      }
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ---------- Wire up ----------
    el('btnLoad').addEventListener('click', async ()=>{
      try{
        await loadTeams();
      }catch(err){
        setStatus('Error');
        setNote(String(err));
        console.error(err);
      }
    });

    el('btnRun').addEventListener('click', async ()=>{
      try{
        await loadTeams(); // safe if already loaded
        document.querySelector('#aggTable tbody').innerHTML = '';
        document.querySelector('#sideTable tbody').innerHTML = '';
        document.querySelector('#scoreTable tbody').innerHTML = '';
        LAST_ROWS = null;
        await runBatch();
      }catch(err){
        setStatus('Error');
        setNote(String(err));
        console.error(err);
      }
    });

    el('btnCSV').addEventListener('click', ()=>{
      if (!LAST_ROWS || !LAST_ROWS.length){
        setNote('No results yet. Run a batch first.');
        return;
      }
      downloadCSV(LAST_ROWS, 'batch_sim_results.csv');
    });

    // auto-load on open (respect query params)
    (async function boot(){
      try{
        await loadTeams();
        setStatus('Ready');
        setNote('Optionally set n/home/away/seed in the fields (or querystring), then Run.');
      }catch(err){
        setStatus('Error');
        setNote(String(err));
        console.error(err);
      }
    })();
  </script>
</body>
</html>

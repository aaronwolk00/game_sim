<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>NFL Sim — GMG (Players + Penalties)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
/* =========================
   LAYOUT SIZING — TWEAK HERE
   ========================= */
:root{
  --left-col:   320px;       /* left panel width */
  --center-min: 900px;      /* min width of the middle stack */
  --right-col:  520px;       /* right panel width */
  --gutter:     16px;        /* space between columns */
  --pad-x:      8px;         /* page side padding (shrinks outer border look) */
  --max-width:  1720px;      /* overall page max */
}

/* ===== Base theme (unchanged) ===== */
:root{
  --bg:#0b1220; --panel:#121a2a; --card:#0e1630; --muted:#93a0b1; --text:#eef2ff;
  --home:#4ade80; --away:#60a5fa; --good:#34d399; --bad:#f87171;
  --los:#93c5fd;   /* LOS */
  --first:#facc15; /* 1st down */
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
header{padding:10px 14px;border-bottom:1px solid #1c2440;display:flex;align-items:center;gap:10px}
h1{margin:0;font-size:16px}

/* ===== SINGLE grid definition ===== */
main{
  display:grid;
  grid-template-columns: var(--left-col) minmax(var(--center-min), 1fr) var(--right-col);
  gap: var(--gutter);
  width: min(var(--max-width), 100vw);
  margin: 0 auto;
  padding: 12px var(--pad-x);
}

/* Collapse to single column on smaller viewports */
@media (max-width: 1400px){
  main{
    grid-template-columns: 1fr;
    width: min(1100px, 98vw);
  }
}

/* Trim margins so the outside doesn’t look like a big border */
.panel, .card, .box, .sidebar, .teambox { margin: 0; }

.panel{background:var(--panel);border-radius:14px;padding:12px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
label{display:block;font-size:11px;color:var(--muted);margin-bottom:6px}
input[type="text"],input[type="number"],select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #243055;background:var(--card);color:var(--text)}
input[type="file"]{width:100%}
.row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.line{height:1px;background:#1c2440;margin:10px 0;border-radius:2px}
button{padding:10px 12px;border-radius:10px;border:none;background:#5eead4;color:#0a0f17;font-weight:700;cursor:pointer}
button.secondary{background:#1e293b;color:#dbe3ef;border:1px solid #2a355a}
button.ghost{background:var(--card);border:1px dashed #334155;color:#cbd5e1}
button:disabled{opacity:.6;cursor:not-allowed}
.scoreboard{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:10px}
.teamName{font-weight:800}
.score{font-size:34px;font-weight:900}
.sub{font-size:11px;color:var(--muted)}
.small{font-size:12px;color:var(--muted)}

.tabs{display:flex;gap:6px;margin-top:6px}
.tab{padding:6px 10px;border-radius:999px;border:1px solid #2a355a;background:#0e1630;color:#cbd5e1;cursor:pointer;font-size:12px}
.tab.active{background:#1e293b;color:#e5e7eb}

.feed{max-height:52vh;overflow:auto;font-size:13px;line-height:1.35}
.item{padding:8px 10px;border-bottom:1px solid #1c2544;border-left:3px solid transparent;display:flex;justify-content:space-between;gap:10px}
.item.home{border-left-color:var(--home)}
.item.away{border-left-color:var(--away)}
.item.score{background:rgba(52,211,153,.06);border-left-color:var(--good)}
.feed{font-size:13px;line-height:1.35}
.item.score{font-size:13px;font-weight:600}
.feed h1,.feed h2,.feed h3{font-size:13px;font-weight:700;margin:0}
.tag{font-size:11px;color:#9cd2ff;background:#1a2444;border-radius:6px;padding:2px 6px;margin-right:6px}
.aux{color:#a3b2c7;font-size:12px;white-space:nowrap}

.table{width:100%;border-collapse:collapse;font-size:12px}
.table th,.table td{border-bottom:1px solid #1f2740;padding:6px 7px;text-align:left}
.right{text-align:right}

.feed .item{ font-size:13px; line-height:1.3; }
.feed .item.score{font-size:13px; line-height:1.25; padding:8px 10px;}
.feed .item.score .tag{font-size:10px}
.feed .item *{ font-size:inherit; }

/* Field & HUD */
.fieldWrap{position:relative;display:grid;gap:6px}
canvas#field{width:100%;height:260px;background:#062b22;border-radius:12px;border:1px solid #0b3a52}
.hudPill{position:absolute;top:6px;left:50%;transform:translateX(-50%);background:rgba(8,12,24,.78);border:1px solid #2a355a;border-radius:999px;padding:4px 10px;font-size:12px;backdrop-filter:blur(2px)}
.lastPlay{background:var(--card);border:1px solid #243055;border-radius:12px;padding:8px;font-size:13px}
.wpBox{display:flex;align-items:center;justify-content:space-between;background:var(--card);border:1px solid #243055;border-radius:12px;padding:6px 8px}
.crowdBox{background:var(--card);border:1px solid #243055;border-radius:12px;padding:8px;margin-top:8px}
.meter{width:100%;height:8px;background:#0e1630;border:1px solid #233055;border-radius:999px;overflow:hidden}
#crowdBar{height:100%;width:0%;background:linear-gradient(90deg,#93c5fd,#34d399);transition:width .25s ease}
.wpVal{font-weight:800}
.pill{display:inline-block;padding:3px 7px;border-radius:8px;background:#0e1630;border:1px solid #233055;color:#cfe1ff;font-size:11px}
.subtabs{display:flex;gap:6px;margin:8px 0}
.subtab{padding:4px 8px;border-radius:8px;border:1px solid #243055;background:#0e1630;color:#d2e0ff;cursor:pointer;font-size:11px}
.subtab.active{background:#1e293b}
</style>
</head>

<body>
<header><h1>NFL Sim — GMG</h1></header>

<main>
  <!-- LEFT -->
  <section class="panel">
    <div class="scoreboard" style="gap:6px;margin-bottom:6px">
      <div class="teamName" id="homeName" style="color:var(--home)">Home</div>
      <div class="score"><span id="homeScore">0</span>–<span id="awayScore">0</span></div>
      <div class="teamName" id="awayName" style="color:var(--away);text-align:right">Away</div>
      <div class="sub" style="grid-column:1/-1">Poss: <span id="poss">Home</span> • Q<span id="qtr">1</span> • <span id="clock">15:00</span> • TO: <span id="toHome">3</span>/<span id="toAway">3</span></div>
    </div>

    <div class="row">
      <div><label>Home Name</label><input id="homeLabel" type="text" value="Home"></div>
      <div><label>Away Name</label><input id="awayLabel" type="text" value="Away"></div>
    </div>

    <div class="row">
      <div><label>Seed</label><input id="seed" type="text" value="2025-A"></div>
      <div><label>Play Speed (ms)</label><input id="speed" type="number" min="0" value="140"></div>
    </div>

    <!-- Teams (auto-populated from the roster .xlsx in this folder) -->
    <div class="row" style="grid-template-columns:1fr">
      <div>
        <label class="small">Loaded Teams</label>
        <div class="row" style="grid-template-columns:1fr 1fr">
          <select id="homeTeamSel"></select>
          <select id="awayTeamSel"></select>
        </div>
        <div id="rosterStatus" class="small" style="margin-top:6px;color:var(--muted)"></div>
        <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap">
          <button id="btnListCsvTeams" class="ghost">List CSV Teams</button>
          <button id="btnForceLocalCsv" class="ghost">Force Local CSV</button>
        </div>
        <pre id="csvOut" class="small"
             style="margin-top:6px;max-height:140px;overflow:auto;white-space:pre-wrap;
                    background:#0e1630;border:1px dashed #334155;padding:6px;border-radius:8px;display:none"></pre>        
      </div>
    </div>

    <div class="line"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" class="secondary" disabled>Pause</button>
      <button id="resetBtn" class="secondary">Reset</button>
      <button id="exportCsv" class="ghost" disabled>Export CSV</button>
    </div>

    <div class="line"></div>
    <details>
      <summary>Game Feel</summary>
      <div class="row" style="margin-top:8px">
        <div><label>Variance</label><input id="feelVariance" type="range" min="0" max="100" value="40"></div>
        <div><label>Ref Strictness</label><input id="feelRefs" type="range" min="0" max="100" value="55"></div>
      </div>
      <div class="row">
        <div><label>Crowd Noise</label><input id="feelCrowd" type="range" min="0" max="100" value="60"></div>
        <div><label>Pace</label><input id="feelPace" type="range" min="0" max="100" value="50"></div>
      </div>
      <div class="row">
        <div><label>Weather</label>
          <select id="precip"><option>None</option><option>Light Rain</option><option>Heavy Rain</option><option>Snow</option></select>
        </div>
        <div><label>Wind (mph)</label><input id="wind" type="number" value="7"></div>
      </div>
      <div class="row">
        <div><label>Temp (°F)</label><input id="temp" type="number" value="45"></div>
        <div><label class="small">Fans auto-managed</label><div class="pill" id="fansPill">Fans: 0</div></div>
      </div>
    </details>

    <div class="line"></div>
    <details>
      <summary>Coaching</summary>
      <div class="row" style="margin-top:8px">
        <div><label>Pass% Early</label><input id="passEarly" type="range" min="30" max="80" value="55"></div>
        <div><label>Pass% Late</label><input id="passLate" type="range" min="35" max="90" value="62"></div>
      </div>
      <div class="row">
        <div><label>4th Aggression</label><input id="aggr4th" type="range" min="0" max="100" value="35"></div>
        <div><label>2-Pt Try %</label><input id="twoPct" type="range" min="0" max="100" value="5"></div>
      </div>
    </details>
  </section>

  <!-- CENTER -->
  <section class="panel">
    <div class="fieldWrap">
      <canvas id="field" width="980" height="260"></canvas>
      <div id="hud" class="hudPill">Q1 • 15:00 • 1st & 10 @ Own 25 • Poss: Home</div>
      <div class="lastPlay" id="lastPlay">Last Play: —</div>
      <div class="wpBox">
        <div>Home Win %: <span id="wpVal" class="wpVal">50.0%</span></div>
        <button id="toggleAdv" class="ghost">PBP: Advanced Off</button>
        <canvas id="wpChart" height="10"></canvas>
      </div>
      <div class="crowdBox">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
          <div>Crowd Impact</div>
          <div class="small"><span id="crowdPct">0%</span></div>
        </div>
        <div class="meter"><div id="crowdBar"></div></div>
      </div>
    </div>
    <div class="line"></div>
    <div class="tabs">
      <button id="tabPlays" class="tab active">Play-by-Play</button>
      <button id="tabScoring" class="tab">Scoring</button>
      <button id="tabDrives" class="tab">Drives</button>
      <button id="tabAdvanced" class="tab">Advanced</button>
    </div>
    <div id="feed" class="feed"></div>
  </section>
  
  <!-- RIGHT -->
  <section class="panel">
    <div style="font-weight:800;margin-bottom:6px">Team Box</div>
    <div id="boxWrap"></div>
    <div class="line"></div>
    <div style="font-weight:800;margin-bottom:6px">Leaders</div>
    <div id="leaders"></div>
    <div class="line"></div>
    <div style="font-weight:800;margin-bottom:6px">Top EPA Plays</div>
    <div id="topEpa" class="small"></div>
  </section>
</main>


<script>

/* ===== Utilities ===== */
// Small helpers
const $id  = (id) => document.getElementById(id);
const bind = (...ids) =>
  ids.reduce((acc, id) => (acc[id] = $id(id), acc), {});


const CSV_DEBUG = true;            // logs fetch attempts + reasons
const CSV_USE_FALLBACK = true;

// One compact grab that preserves your variable names
const {
  crowdPct, crowdBar, startBtn, pauseBtn, resetBtn, exportCsv, topEpa, rosterStatus, toggleAdv,
  field, wpChart, homeName, awayName, homeScore, awayScore, poss, qtr, clock, toHome, toAway,
  wpVal, feed, lastPlay, boxWrap, leaders, tabPlays, tabScoring, tabDrives, tabAdvanced, fansPill,
  hud, homeTeamSel, awayTeamSel, homeLabel, awayLabel, seed, speed, feelVariance, feelRefs, feelCrowd,
  feelPace, precip, wind, temp, passEarly, passLate, aggr4th, twoPct, btnListCsvTeams, csvOut, btnForceLocalCsv
} = bind(
  'crowdPct','crowdBar','startBtn','pauseBtn','resetBtn','exportCsv','topEpa','rosterStatus','toggleAdv',
  'field','wpChart','homeName','awayName','homeScore','awayScore','poss','qtr','clock','toHome','toAway',
  'wpVal','feed','lastPlay','boxWrap','leaders','tabPlays','tabScoring','tabDrives','tabAdvanced','fansPill',
  'hud','homeTeamSel','awayTeamSel','homeLabel','awayLabel','seed','speed','feelVariance','feelRefs','feelCrowd',
  'feelPace','precip','wind','temp','passEarly','passLate','aggr4th','twoPct','btnListCsvTeams','csvOut','btnForceLocalCsv'
);

btnListCsvTeams.onclick = () => {
  let msg = '';
  if (!PLAYERS_CSV_ROWS) {
    msg = 'CSV not loaded yet.\n\nTip: If you opened this HTML via file:// most browsers block fetch(). Serve it via localhost (e.g., `python -m http.server`).';
  } else {
    msg = `Teams found (${TEAM_SHEETS.length}):\n` + TEAM_SHEETS.join(', ');
  }
  csvOut.textContent = msg;
  csvOut.style.display = 'block';
};

btnForceLocalCsv.onclick = async () => {
  rosterStatus.textContent = 'Forcing local CSV (players.csv / Players.csv)...';
  const ok = await tryLoadPlayersCsv(true); // forceLocal = true
  rosterStatus.textContent = ok
    ? `Loaded ${TEAM_SHEETS.length} teams from CSV (local)`
    : 'Failed to load local CSV — still using generated players.';
  // also dump list
  btnListCsvTeams.click();
};



/* ===== WP toggle (UI injected) ===== */
let showWP = true;
(function addWPToggle(){
  try{
    const btn = document.createElement('button');
    btn.id = 'toggleWP';
    btn.className = 'pill';
    btn.style.marginLeft = '8px';
    btn.textContent = 'WP: On';
    (toggleAdv?.parentElement || toggleAdv)?.insertBefore
      ? toggleAdv.parentElement.insertBefore(btn, toggleAdv.nextSibling)
      : (toggleAdv?.after ? toggleAdv.after(btn) : document.body.appendChild(btn));
    btn.addEventListener('click', () => {
      showWP = !showWP;
      btn.textContent = 'WP: ' + (showWP ? 'On' : 'Off');
      renderPlays(); // re-render with/without ΔWP
    });
  }catch(e){ console.warn('WP toggle mount failed', e); }
})();


// URL params
const PARAMS = new URLSearchParams(location.search);

// Support either explicit ?home=&away= OR a single ?matchup= like "Giants vs Falcons"
const URL_MATCHUP = (PARAMS.get('matchup') || '').trim();
let URL_HOME = (PARAMS.get('home') || '').trim();
let URL_AWAY = (PARAMS.get('away') || '').trim();

// Parse "A vs B", "A v. B", "A @ B", "A - B", or "A — B"
if (!URL_HOME && !URL_AWAY && URL_MATCHUP){
  const parts = URL_MATCHUP
    .replace(/\s+/g,' ')
    .trim()
    .split(/\s*(?:vs\.?|v\.?|@|-|—)\s*/i)
    .map(s => s.trim())
    .filter(Boolean);
  if (parts.length >= 2){
    [URL_HOME, URL_AWAY] = parts.slice(0,2);
  }
}

// If players param given, normalize possible refs/heads URL → raw
const RAW_PLAYERS_PARAM = (PARAMS.get('players') || '').replace('/refs/heads/', '/');

// Optional autostart support (?autostart=1)
const URL_AUTOSTART = PARAMS.has('autostart');

// Fallback CSV so the app works even with no ?players= in the URL
const FALLBACK_PLAYERS_URL = 'https://raw.githubusercontent.com/aaronwolk00/game_sim/main/players.csv';



function logPlay(tag, line, off, scoring=false, epa=null, wpd=null, driveEp=null){
  plays.push({ tag, line, off, scoring, epa, wpd, driveEp });

  if (activeTab === 'plays') renderPlays();
  lastPlay.textContent = 'Last Play: ' + line.replace(/^.* — /,''); // keep your suffix trim

  // Track EPA → Top EPA Plays
  if (epa !== null && Number.isFinite(epa)){
    const short = line.replace(/^Q\d+\s+\d+:\d+\s+\|\s+[^—]+—\s*/,'').trim();
    epaPlays.push({ epa, text: short });
    if (epaPlays.length > 800) epaPlays.shift();
    renderTopEpa();
  }
}



let showAdvanced=false; toggleAdv.onclick=()=>{showAdvanced=!showAdvanced; toggleAdv.textContent='PBP: '+(showAdvanced?'Advanced On':'Advanced Off'); renderPlays();};
function hash32(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=(h<<13)|(h>>>19);}return(h>>>0);}
function rngFromSeed(s){let a=hash32(s)||1;return()=>{a=(a+0x6D2B79F5)>>>0;let t=Math.imul(a^(a>>>15),1|a);t^=t+Math.imul(t^(t>>>7),61|t);return((t^(t>>>14))>>>0)/4294967296;};}
function randNorm(r,m=0,s=1){const u=Math.max(1e-12,r()), v=r();return m+Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)*s;}
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function yardText(y){return y>=50?`Opp ${100-y}`:`Own ${y}`;}
function dnTxt(d){return ['1st','2nd','3rd','4th'][d-1]}

/* ===== CSV / roster ===== */
// Robust CSV parsing with BOM handling and reliable header detection.
// Assumes the first REAL row is the header; tolerates a few junk/blank lines before it.

const TEAM_COL = 'Team';

function stripBOM(s){ return s.replace(/^\uFEFF/, ''); }

/** Basic CSV parser (RFC4180-ish): handles quotes, commas, and newlines inside quotes. */
function parseCSV(text){
  text = stripBOM(String(text || ''));
  const rows = [];
  let row = [], field = '', inQuotes = false;

  for (let i = 0; i < text.length; i++){
    const c = text[i];

    if (inQuotes){
      if (c === '"'){
        if (text[i+1] === '"'){ field += '"'; i++; }   // escaped quote
        else { inQuotes = false; }
      } else {
        field += c;
      }
    } else {
      if (c === '"'){
        inQuotes = true;
      } else if (c === ','){
        row.push(field); field = '';
      } else if (c === '\n'){
        row.push(field); rows.push(row);
        row = []; field = '';
      } else if (c !== '\r'){
        field += c;
      }
    }
  }
  // push last field/row
  row.push(field); rows.push(row);

  // Trim trailing empty lines
  while (rows.length && rows[rows.length-1].every(x => String(x||'').trim()==='')) rows.pop();

  if (!rows.length) return [];

  // Header row → object array
  // Deduplicate header names if necessary (e.g., repeated "BLANK")
  const rawHeader = rows.shift().map(h => String(h||'').trim());
  const seen = new Map();
  const header = rawHeader.map(h => {
    if (!h) h = 'col';
    const base = h;
    let k = h, idx = 2;
    while (seen.has(k)) { k = `${base}_${idx++}`; }
    seen.set(k, true);
    return k;
  });

  return rows
    .filter(r => r && r.some(x => String(x||'').trim() !== ''))
    .map(r => {
      const obj = {};
      for (let i = 0; i < header.length; i++){
        obj[header[i]] = r[i] === undefined ? '' : r[i];
      }
      // Trim whitespace on all string fields
      for (const k in obj){
        if (typeof obj[k] === 'string') obj[k] = obj[k].trim();
      }
      return obj;
    });
}

/**
 * Smart wrapper: skips any leading junk/blank lines and starts at the first line
 * that looks like a real header (contains "Team" and "Position", or matches "^#,Team,Position").
 */
function parseCSVSmart(text){
  text = stripBOM(String(text || ''));
  const lines = text.split(/\r?\n/);

  let headerIdx = -1;
  for (let i = 0, seen = 0; i < lines.length && seen < 12; i++){
    const raw = lines[i];
    if (!raw.trim()) continue;
    seen++;

    const li = raw.toLowerCase();
    const looksLikeHeader =
      /^#\s*,\s*team\s*,\s*position/i.test(raw) ||
      (li.includes('team') && li.includes('position'));

    if (looksLikeHeader){
      headerIdx = i;
      break;
    }
  }
  if (headerIdx < 0) headerIdx = 0; // fallback: assume first line is header

  const sliced = lines.slice(headerIdx).join('\n');
  const rows = parseCSV(sliced);

  // Final sanity: ensure "Team" column exists (caller expects it).
  // If it's missing, leave as-is; the loader will warn and fall back.
  return rows;
}


function num(x,d=70){const v=Number(x);return Number.isFinite(v)?v:d;}
const OLp=new Set(['LT','LG','C','RG','RT','OL']), DLp=new Set(['DT','NT','DE','IDL']), EDGEp=new Set(['EDGE']), LBp=new Set(['LB','MLB','ILB','OLB']), DBp=new Set(['CB','NB','DB','S','FS','SS']);
function pOVR(p){if(p.OVR!==undefined&&p.OVR!=='') return num(p.OVR,70);const SPD=num(p.SPD,70),STR=num(p.STR,70),AGI=num(p.AGI,70),INT=num(p.INT,70),TEC=num(p.TEC,70),H=num(p.HANDS,70),T=num(p.TACK,70),B=num(p.BLOCK,70),C=num(p.COVER,70),PA=num(p.PASS_ACC,70),PP=num(p.PASS_PWR,70);const pos=(p.Position||'').toUpperCase();if(pos==='QB')return 0.55*PA+0.25*PP+0.2*INT;if(pos==='WR'||pos==='TE'||pos==='RB')return 0.4*SPD+0.2*AGI+0.2*H+0.2*INT;if(OLp.has(pos))return 0.5*B+0.2*STR+0.2*TEC+0.1*INT;if(DLp.has(pos)||EDGEp.has(pos))return 0.35*STR+0.25*TEC+0.2*AGI+0.2*T;if(LBp.has(pos))return 0.3*T+0.25*INT+0.25*AGI+0.2*STR;if(DBp.has(pos))return 0.35*C+0.25*AGI+0.2*INT+0.2*T;return (SPD+STR+AGI+INT+TEC+H+T+B+C+PA+PP)/11;}
function buildTeam(rows){
  const players=rows.map((r,i)=>({id:i,first:r['First Name'],last:r['Last Name'],pos:(r['Position']||'').toUpperCase(),
    OVR:pOVR(r), SPD:+r.SPD||70, STR:+r.STR||70, AGI:+r.AGI||70, INT:+r.INT||70, TEC:+r.TEC||70, HANDS:+r.HANDS||70, TACK:+r.TACK||70, BLOCK:+r.BLOCK||70, COVER:+r.COVER||70, PASS_ACC:+r.PASS_ACC||70, PASS_PWR:+r.PASS_PWR||70, KICK_POW:+r.KICK_POW||70, KICK_ACC:+r.KICK_ACC||70, DISC:+r.DISC||70,
    adv:{att:0,comp:0,yards:0,td:0,int:0,sacks:0,dropbacks:0,pressures:0,ttt:0,tttN:0,air:0,yac:0,targets:0,catches:0,drops:0,sep:0,sepN:0,fast:0,ayDepth:0,ayN:0,tkl:0,sk:0,pd:0,ints:0,ry:0,carries:0,recY:0}}));
  const by=new Map();players.forEach(p=>{if(!by.has(p.pos))by.set(p.pos,[]);by.get(p.pos).push(p);});for(const v of by.values()) v.sort((a,b)=>pOVR(b)-pOVR(a));
  const get=(pos,n)=>(by.get(pos)||[]).slice(0,n); const top=(set,n)=>players.filter(p=>set.has(p.pos)).sort((a,b)=>pOVR(b)-pOVR(a)).slice(0,n);
  const qb=get('QB',1)[0]; const wr=get('WR',5); const te=get('TE',3); const rb=get('RB',3); const k=get('K',1)[0]; const p=get('P',1)[0];
  const dl=top(new Set([...DLp,...EDGEp]),7), lb=top(LBp,5), db=top(DBp,6), ol=top(OLp,7);
  const offense=[qb&&{w:4,val:pOVR(qb)},...rb.slice(0,2).map(x=>({w:1,val:pOVR(x)})),...wr.slice(0,3).map(x=>({w:1.2,val:pOVR(x)})),...te.slice(0,1).map(x=>({w:1,val:pOVR(x)})),...ol.slice(0,5).map(x=>({w:0.6,val:pOVR(x)}))].filter(Boolean);
  const off=offense.reduce((a,b)=>a+b.w*b.val,0)/(offense.reduce((a,b)=>a+b.w,0)||1);
  const dparts=[]; dl.slice(0,4).forEach(x=>dparts.push({w:1.2,val:pOVR(x)})); lb.slice(0,3).forEach(x=>dparts.push({w:1,val:pOVR(x)})); db.slice(0,4).forEach(x=>dparts.push({w:1.1,val:pOVR(x)}));
  const def=dparts.reduce((a,b)=>a+b.w*b.val,0)/(dparts.reduce((a,b)=>a+b.w,0)||1);
  return {players,qb,wr,te,rb,k,p,dl,lb,db,offense:off,defense:def,special:(k&&p)?(0.5*(0.7*k.KICK_ACC+0.3*k.KICK_POW)+0.5*(0.7*p.KICK_POW+0.3*p.KICK_ACC)):70,
    stats:{team:{plays:0,yards:0,passYds:0,rushYds:0,punts:0,fgm:0,fga:0,td:0,ints:0,downs:0,pen:0,third:{c:0,a:0},fourth:{c:0,a:0},epa:0}},
    drives:[]};
}

/* ===== EP/WP ===== */
const sigmEP = z => 1/(1+Math.exp(-z));
const clamp01 = x => Math.max(0, Math.min(1, x));

// Base EP from yardline (own GL ≈ -1.40 → opp GL ≈ +6.00), slope at midfield ≈ 0.12
const EP_LLO   = -1.40;
const EP_LHI   =  6.00;
const EP_RANGE = (EP_LHI - EP_LLO);
const EP_SLOPE_MID = 0.12;
const EP_K     = EP_RANGE / (4*EP_SLOPE_MID); // ~15.42

function EP_base_from_y(y){
  const yy = clamp(Math.round(y), 1, 99);
  return EP_LLO + EP_RANGE * sigmEP((yy - 50)/EP_K);
}

// 1st-down probability by down & distance (smooth logistic, no tables)
function pFirstDown(down, dist){
  const d = Math.max(1, Math.min(25, Math.round(dist||10)));
  const cfg = {
    1: {a: -2.047, b: 0.12},  // p(10) ~0.70
    2: {a: -1.399, b: 0.16},  // p(10) ~0.45
    3: {a: -1.101, b: 0.22},  // p(10) ~0.25
    4: {a: -1.013, b: 0.35},  // p(1)  ~0.66, p(10)~0.08
  }[down] || {a:-1.399, b:0.16};
  const z = -(cfg.a + cfg.b * d);
  return clamp01(1/(1+Math.exp(-z)));
}

// Smooth net punt yards from LOS (coarse but monotone)
function netPuntFromLOS(y){
  const field = clamp(y, 1, 99);
  const base  = 42;
  const ownDepth = Math.max(0, 50 - field);
  const oppDepth = Math.max(0, field - 50);
  const adj = -0.08*ownDepth - 0.10*oppDepth;
  return clamp(Math.round(base + adj), 28, 50);
}

// Final EP(down,dist,y): blend success vs fail (fail ~ eventual punt)
function EP(down, dist, y){
  // base from yardline (your logistic)
  const base = EP_base_from_y(y);

  // Down/distance pressure; harsher when far from the end zone
  const fieldFrac = y/100;                    // 0 own GL → 1 opp GL
  const damp      = 0.55 + 0.45*(1 - fieldFrac); // more penalty far from EZ

  const d = clamp(Math.round(dist||10), 1, 50);

  // Stronger separation by down so 2nd < 1st (and 3rd/4th harsher)
  const downAdjBase = [0, -0.70, -1.45, -2.35][(down|0)-1] ?? -2.0;
  const downAdj = downAdjBase * damp;

  // Distance hurts more on 3rd/4th than 1st/2nd
  const distSlope = (down>=3 ? 0.055 : 0.035);
  const distAdj = -distSlope * d * damp;

  // Extra long-yardage malus on 3rd/4th (e.g., 3rd & 18)
  const longYds = Math.max(0, d - 10);
  const longAdj = (down>=3 ? -0.10 * Math.min(longYds, 20) * damp : 0);

  return clamp(base + downAdj + distAdj + longAdj, -2.5, 6.95);
}


/* ===== Pre-snap DriveEP (offense-only expected points for *this* drive) ===== */
const _fgProb = (dist, pow=70, acc=70) =>
  (typeof fgMakeProb === 'function')
    ? fgMakeProb(dist, pow, acc)
    : clamp(0.95 - 0.012*Math.max(0, dist-33), 0.05, 0.99); // simple fallback


function driveEPForState(snap, homeTeam, awayTeam){
  const { poss, down, dist, yard } = snap;
  const atk = (poss === 'Home') ? homeTeam : awayTeam;
  const def = (poss === 'Home') ? awayTeam  : homeTeam;

  // Evaluate a 4th-down choice from current spot
  function epFourth(dist4){
    const distGL = 100 - yard;
    const FGdist = Math.round(distGL + 17);
    const k = atk.k || { KICK_POW:70, KICK_ACC:70 };

    // FG expected value
    const ep_fg = (FGdist <= 68) ? (3 * fgMakeProb(FGdist, k.KICK_POW, k.KICK_ACC)) : -Infinity;

    // Go-for-it expected value (only if short)
    const goThresh = (yard >= 50 ? 4.0 : 2.0) - ((+aggr4th.value - 50)/25);
    let ep_go = -Infinity;
    if (dist4 <= goThresh){
      const pConv = clamp(0.48 + (atk.offense - def.defense)/220, 0.30, 0.70);
      const ep_after = EP(1, Math.min(10, 100 - yard), yard);
      ep_go = pConv * ep_after;     // fail → 0 for this drive
    }

    // Punt contributes ~0 to *this drive’s* points
    const ep_punt = 0;

    return clamp(Math.max(ep_fg, ep_go, ep_punt, 0), 0, 6.95);
  }

  // On actual 4th down, choose immediately
  if (down === 4){
    return epFourth(dist);
  }

  // 1st–3rd down: expected value of (convert the series) vs (fail → 4th-down choice)
  const pConv   = clamp(pFirstDown(down, dist), 0, 1); // your logistic
  const convEP  = clamp(EP(1, Math.min(10, 100 - yard), yard), 0, 6.95);

  // Assume fail yields 4th from (roughly) the same spot & distance (conservative)
  let fallback = epFourth(dist);

  // Small risk haircut for obvious pass on 3rd & long already in FG range
  if (down === 3 && dist >= 12 && yard >= 70) fallback = Math.max(0, fallback - 0.25);

  const mix = pConv * convEP + (1 - pConv) * fallback;
  return clamp(mix, 0, 6.95);
}




let wpSeries=[0.5], wpSmooth=0.5, wpPrior=0.5;
function priorFromTeams(h,a){const sH=(h.offense+h.defense)/2,sA=(a.offense+a.defense)/2;return clamp(1/(1+Math.exp(-(sH-sA)/8)),0.35,0.65);}
const logit = x => Math.log(x/(1-x));
const invlogit = z => 1/(1+Math.exp(-z));


// ===== WP endgame helpers (place ABOVE stateWP) =====
const ONSIDE_P = 0.08; // assumed onside success rate (used for multi-score cap)

/** How many 8-point possessions are needed to erase a deficit */
function _needScores(absLead){
  return Math.ceil(absLead / 8);
}

/** Extra clock the trailing team can realistically "buy" (timeouts + 2MW) */
function _stoppageCredit(q, s, trailingTO){
  // Add ~38s per timeout (stop the clock + runoff prevention); generous but realistic.
  let credit = 38 * Math.max(0, trailingTO|0);
  // If we're still before the 2:00 warning in Q4, add one more ~38s credit.
  const tLeft = (5 - q) * 900 + s;
  if (q === 4 && s > 120) credit += 38;
  // Cap total credit so it can’t exceed two full plays worth.
  return Math.min(120, credit);
}

/** Very fast possession lengths late (hurry-up/no huddle) */
function _secPerPoss(haveBall){
  // If you already have the ball, no kickoff/punt transition tax.
  return haveBall ? 52 : 64; // seconds
}

/** Upper bound for trailing WP when NP>=2 late (onside chains become tiny) */
function _multiScoreCap(np, tLeft){
  if (np <= 1) return 1;
  const chain = Math.pow(ONSIDE_P, np - 1);
  // A small ceiling that tightens as time dwindles
  if (tLeft <= 120) return 0.004 * chain;
  if (tLeft <= 300) return 0.010 * chain;
  if (tLeft <= 480) return 0.020 * chain;
  return 0.035 * chain;
}


function stateWP(hs, as, q, s, y, p, prior){
  const tLeft = (5 - q) * 900 + s;         // seconds left
  const tf    = clamp(1 - tLeft/3600, 0, 1);
  const lead  = hs - as;
  const possSign = (p === 'Home') ? 1 : -1;

  // Base logistic (field/score/prior + a modest EP nudge)
  const zPrior = logit(clamp(prior, 0.05, 0.95)) * (0.55 - 0.30*tf);
  const zLead  = (0.35 + 1.05*tf) * (lead/7);
  const zField = 0.20 * ((y - 50)/50) * possSign;
  const epNow  = EP(sim.hud.down, sim.hud.dist, y);
  const zEP    = 0.10 * ((p === 'Home') ? epNow : -epNow) / 6;
  let wp = clamp(invlogit(zPrior + zLead + zField + zEP), 0.001, 0.999);

  // Possession budget for the TRAILING side (fast end-game pace)
  const timeoutsHome = timeouts.Home || 0;
  const timeoutsAway = timeouts.Away || 0;
  const trailing = lead>0 ? 'Away' : (lead<0 ? 'Home' : null);
  const trailingTO = trailing ? (timeouts[trailing]||0) : 0;
  const trailingHasBall = trailing ? (p === trailing) : false;

  const hurry       = (tLeft <= 240);
  const secPerPoss  = hurry ? 55 : 70;     // faster pace late
  const onsideP     = 0.03;                // keep tiny unless you model real onside
  const bonusTO     = 28 * trailingTO;     // ~28s of saved clock per TO
  let possLeft      = Math.floor((tLeft + bonusTO)/secPerPoss) + (trailingHasBall ? 1 : 0);
  const needScores  = Math.ceil(Math.abs(lead)/8);   // allow 2-pt (8 each)

  // If they physically can’t get enough possessions → shove to leader
  if (trailing && needScores > possLeft){
    const scarcity = needScores - possLeft;       // 1+ => impossible without miracles
    const lock     = Math.pow(clamp(1 - tLeft/300, 0, 1), 2.2); // grows last 5:00
    const target   = clamp(0.96 + 0.02*scarcity, 0.96, 0.999);
    const homeTarget = (lead>0) ? target : (1 - target);
    wp = (1 - lock)*wp + lock*homeTarget;
  }

  // Kneel-out detection: leader with ball runs out clock (defense has TOs)
  const leader = lead>0 ? 'Home' : (lead<0 ? 'Away' : null);
  const leaderHasBall = leader && (p === leader);
  if (leader && leaderHasBall){
    const defTO        = (leader==='Home') ? timeoutsAway : timeoutsHome;
    const kneelBudget  = 3*40 + 40*defTO;  // three kneels + TO burn (very conservative)
    if (tLeft <= kneelBudget){
      const lock      = Math.pow(clamp(1 - (tLeft - 20)/kneelBudget, 0, 1), 1.8);
      const homeTarget= (leader==='Home') ? 0.999 : 0.001;
      wp = (1 - lock)*wp + lock*homeTarget;
    }
  }

  // Two-score late reinforcement: e.g., +14 with 1:21 and ball → ~99%+
  if (Math.abs(lead) >= 14 && tLeft <= 121){
    const lock      = Math.pow(clamp(1 - tLeft/121, 0, 1), 1.5);
    const homeTarget= (lead>0) ? 0.992 : 0.008;
    wp = (1 - lock)*wp + lock*homeTarget;
  }

  // Absolutely impossible in final seconds (prevents 12–16% nonsense)
  if (tLeft <= 30 && Math.abs(lead) >= 25){
    wp = lead>0 ? 0.9995 : 0.0005;
  }

  return clamp(wp, 0.0001, 0.9999);
}



// Add a helper for a time-aware ΔWP cap (small early, big late)
function wpCap(q, s){
  const tLeft = (5 - q) * 900 + s;
  const tf = clamp(1 - tLeft/3600, 0, 1);
  // A bit higher late so single plays can move WP more when they must
  return 0.03 + 0.70*Math.pow(tf, 2.25);
}

function drawWP(){const c=wpChart;const w=c.width=300,h=c.height=110,ctx=c.getContext('2d');ctx.clearRect(0,0,w,h);ctx.strokeStyle='#243055';ctx.beginPath();for(let y=0;y<=h;y+=h/4){ctx.moveTo(0,y);ctx.lineTo(w,y);}ctx.stroke();if(wpSeries.length>1){ctx.strokeStyle='#5eead4';ctx.lineWidth=2;ctx.beginPath();for(let i=0;i<wpSeries.length;i++){const x=i*(w/(wpSeries.length-1));const y=(1-wpSeries[i])*h;if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();}}

/* ===== Field ===== */
const Field=(()=>{function base(ctx,w,h,qtr){const l=w*0.06,r=w*0.94,top=12,bot=h-12;const g=ctx.createLinearGradient(0,top,0,bot);g.addColorStop(0,'#0b5d49');g.addColorStop(1,'#0a4f3f');ctx.fillStyle=g;ctx.fillRect(l,top,r-l,bot-top);ctx.strokeStyle='#c7f9ec';ctx.strokeRect(l,top,r-l,bot-top);const flip=(qtr%2===0);ctx.fillStyle='rgba(15,40,60,.55)';ctx.fillRect(l,top,(r-l)/20,bot-top);ctx.fillStyle='rgba(60,25,25,.55)';ctx.fillRect(l+(r-l)*19/20,top,(r-l)/20,bot-top);ctx.fillStyle='#d1fae5';ctx.font='bold 14px system-ui';ctx.fillText(flip?'AWAY':'HOME',l+8,top+16);ctx.fillText(flip?'HOME':'AWAY',r-62,top+16);for(let i=0;i<=20;i++){const x=l+(r-l)*i/20;ctx.strokeStyle='#e2e8f0';ctx.lineWidth=(i%5===0?1.4:0.8);ctx.beginPath();ctx.moveTo(x,top);ctx.lineTo(x,bot);ctx.stroke();if(i>0&&i<20&&i!==10){ctx.fillStyle='#d1fae5';ctx.font='11px system-ui';const n=(i<=10?i*5:(20-i)*5);ctx.fillText(n.toString(),x-7,top+12);ctx.save();ctx.translate(x+7,bot-4);ctx.rotate(Math.PI);ctx.fillText(n.toString(),0,0);ctx.restore();}}return {l,r,top,bot};}
function yardToX(y,w,l,r){return l+(r-l)*(y/100);}
return{render(state){const c=field,w=c.width,h=c.height,ctx=c.getContext('2d');const b=base(ctx,w,h,state.hud.qtr);const xLOS=yardToX(state.hud.yard,w,b.l,b.r);const x1D=yardToX(Math.min(100,state.hud.yard+state.hud.dist),w,b.l,b.r);ctx.strokeStyle='#93c5fd';ctx.setLineDash([5,7]);ctx.lineWidth=1.3;ctx.beginPath();ctx.moveTo(xLOS,b.top);ctx.lineTo(xLOS,b.bot);ctx.stroke();ctx.setLineDash([]);if(state.hud.yard+state.hud.dist<100){ctx.strokeStyle='#facc15';ctx.setLineDash([6,8]);ctx.lineWidth=1.3;ctx.beginPath();ctx.moveTo(x1D,b.top);ctx.lineTo(x1D,b.bot);ctx.stroke();ctx.setLineDash([]);}ctx.fillStyle='#f59e0b';ctx.beginPath();ctx.ellipse(xLOS+4,(b.top+b.bot)/2,6,4,0,0,Math.PI*2);ctx.fill();}}})();

/* ===== Sim state & UI ===== */
let HOME=null, AWAY=null, running=false, paused=false, sim=null, pendingKickoff=null, pendingPAT=null, pendingScoreIdx=-1;

// ---- Late-game / clock management flags ----
let twoMinUsed = { H1:false, H2:false };  // 2:00 warning fired once per half
let lastTimeoutCalledAt = { Home: 9999, Away: 9999 }; // "time-left" at last TO to avoid spamming
const TO_MIN_GAP = 14;  // don't burn timeouts on back-to-back snaps (seconds of game clock)

// For logging timeouts cleanly
function logTimeout(team, reason=''){
  timeouts[team] = Math.max(0, (timeouts[team]||0) - 1);
  if (team === 'Home') toHome.textContent = timeouts.Home;
  else toAway.textContent = timeouts.Away;
  logPlay('TIMEOUT', `Timeout — ${team}${reason?` (${reason})`:''}`, team, false, 0, 0, 0);
}

// Decide whether *defense* should stop the clock after an in-bounds play
function wantDefenseTO(teamOnDefense, tLeft, diff, h){
  // trailing and late => use TO to preserve time after in-bounds plays
  const trailing = (teamOnDefense === 'Home') ? (diff < 0) : (diff > 0);
  if (!trailing) return false;
  if (timeouts[teamOnDefense] <= 0) return false;
  // get stricter as time dwindles
  if (tLeft <= 180) return true;          // final 3:00
  if (tLeft <= 300 && Math.abs(diff) <= 8) return true; // <=5:00 in one-score game
  return false;
}

// Decide whether *offense* should stop the clock after an in-bounds play
function wantOffenseTO(teamOnOffense, tLeft, diff){
  const offenseIsHome = (teamOnOffense === 'Home');
  const trailing = offenseIsHome ? (diff < 0) : (diff > 0);
  if (!trailing) return false;
  if (timeouts[teamOnOffense] <= 0) return false;

  if (tLeft <= 140) return true;          // under 2:20, typical hurry
  if (tLeft <= 300 && Math.abs(diff) >= 9) return true; // two-possession chase under 5:00
  return false;
}

/**
 * Apply clock runoff for a play, but interpose:
 *  - Two-minute warning (2Q/4Q)
 *  - Timeouts by offense/defense when appropriate
 *
 * @param {number} runOffSec - seconds to take off if clock would run
 * @param {object} ctx - { inBounds:boolean, offense:'Home'|'Away', scored?:boolean, pat?:boolean }
 */
function applyClock(runOffSec, ctx){
  const h = sim.hud, s = sim.score;
  const offense = ctx.offense;
  const defense = (offense === 'Home') ? 'Away' : 'Home';

  // Calculate time before the play finishes
  let tLeftBefore = (5 - h.qtr) * 900 + h.secs;

  // If the play ends out-of-bounds/incomplete/score, the game clock is stopped.
  // In that case, we don't burn runOffSec (but still check 2MW if a running clock crossed it).
  let newSecs = h.secs;

  if (ctx.inBounds) {
    // Clock would have run → allow timeouts to shrink the effective runoff
    let useRunoff = runOffSec;

    // Late-game: defense first tries to stop it if trailing
    const diff = s.home - s.away; // + = Home leads
    const tLeftAfterPlay = Math.max(0, tLeftBefore - useRunoff);
    const sinceLastTO_Def = Math.abs((lastTimeoutCalledAt[defense]||9999) - tLeftBefore);

    let tookTO = false;

    if (wantDefenseTO(defense, tLeftBefore, diff, h) && sinceLastTO_Def >= TO_MIN_GAP){
      // Sim effect: shave ~10s of between-plays bleed
      useRunoff = Math.max(6, useRunoff - 10);
      lastTimeoutCalledAt[defense] = tLeftBefore;
      logTimeout(defense, 'defense');
      tookTO = true;
    }

    // If offense is the trailing side and defense didn't just take one, let offense take one
    const sinceLastTO_Off = Math.abs((lastTimeoutCalledAt[offense]||9999) - tLeftBefore);
    if (!tookTO && wantOffenseTO(offense, tLeftBefore, diff) && sinceLastTO_Off >= TO_MIN_GAP){
      useRunoff = Math.max(6, useRunoff - 10);
      lastTimeoutCalledAt[offense] = tLeftBefore;
      logTimeout(offense, 'offense');
      tookTO = true;
    }

    newSecs = Math.max(0, h.secs - useRunoff);
  } else {
    // Stoppage (incomplete, OOB, score, some penalties). Keep clock as-is.
    newSecs = h.secs;
  }

  // Two-minute warning: only fires once per half, when a *running* clock would cross 2:00.
  // It occurs at 2:00 of Q2 and Q4.
  const is2MWQuarter = (h.qtr === 2 || h.qtr === 4);
  const halfKey = (h.qtr <= 2) ? 'H1' : 'H2';
  const crossing2MW = (h.secs > 120 && newSecs < 120);

  if (ctx.inBounds && is2MWQuarter && !twoMinUsed[halfKey] && crossing2MW){
    // Stop exactly at 2:00 and mark used
    newSecs = 120;
    twoMinUsed[halfKey] = true;
    logPlay('TIME', 'Two-Minute Warning', h.poss, false, 0, 0, 0);
  }

  h.secs = newSecs;
}


let plays=[], scoring=[], drives=[]; let timeouts={Home:3,Away:3};
let epaPlays = [];
let TEAM_SHEETS = [];            // list of team names (from CSV "Team" column)
let PLAYERS_CSV_ROWS = null;     // parsed rows of players.csv

function updateHUD(){const h=sim.hud;hud.textContent=`Q${h.qtr} • ${Math.floor(h.secs/60)}:${String(h.secs%60).padStart(2,'0')} • ${dnTxt(h.down)} & ${Math.max(1,Math.round(h.dist))} @ ${yardText(h.yard)} • Poss: ${h.poss}`;}
function updateScore(){const s=sim.score;homeScore.textContent=s.home;awayScore.textContent=s.away;poss.textContent=sim.hud.poss;qtr.textContent=sim.hud.qtr;clock.textContent=`${Math.floor(sim.hud.secs/60)}:${String(sim.hud.secs%60).padStart(2,'0')}`;}
function renderPlays(){
  feed.innerHTML = '';
  const fmtAux = (p) => {
    const bits = [];
    if (Number.isFinite(p.epa))    bits.push(`EPA ${(p.epa>=0?'+':'')}${p.epa.toFixed(2)}`);
    if (showWP && Number.isFinite(p.wpd)) bits.push(`ΔWP ${(p.wpd>=0?'+':'')}${(p.wpd*100).toFixed(1)}%`);
    if (Number.isFinite(p.driveEp)) bits.push(`DriveEP ${p.driveEp.toFixed(2)}`);
    return bits.join(' | ');
  };
  plays.forEach(p => {
    const d = document.createElement('div');
    d.className = 'item ' + (p.scoring ? 'score' : (p.off === 'Home' ? 'home' : 'away'));
    const left  = `<span class="tag">${p.tag}</span>${p.line}`;
    const right = showAdvanced ? `<div class="aux">${fmtAux(p)}</div>` : '';
    d.innerHTML = `<div>${left}</div>${right}`;
    feed.prepend(d);
  });
}

function renderBox(){const H=HOME?.stats.team||{},A=AWAY?.stats.team||{};boxWrap.innerHTML=`<table class="table"><thead><tr><th></th><th>Plays</th><th>Yards</th><th>Pass</th><th>Rush</th><th>Punts</th><th>FG</th><th>TD</th><th>INT</th><th>Pen</th><th>3rd</th><th>4th</th><th>EPA</th></tr></thead><tbody>
<tr><th>${homeLabel.value}</th><td>${H.plays||0}</td><td>${H.yards||0}</td><td>${H.passYds||0}</td><td>${H.rushYds||0}</td><td>${H.punts||0}</td><td>${H.fgm||0}/${H.fga||0}</td><td>${H.td||0}</td><td>${H.ints||0}</td><td>${H.pen||0}</td><td>${(H.third?.c||0)}/${(H.third?.a||0)}</td><td>${(H.fourth?.c||0)}/${(H.fourth?.a||0)}</td><td>${(H.epa||0).toFixed?.(2)||'0.00'}</td></tr>
<tr><th>${awayLabel.value}</th><td>${A.plays||0}</td><td>${A.yards||0}</td><td>${A.passYds||0}</td><td>${A.rushYds||0}</td><td>${A.punts||0}</td><td>${A.fgm||0}/${A.fga||0}</td><td>${A.td||0}</td><td>${A.ints||0}</td><td>${A.pen||0}</td><td>${(A.third?.c||0)}/${(A.third?.a||0)}</td><td>${(A.fourth?.c||0)}/${(A.fourth?.a||0)}</td><td>${(A.epa||0).toFixed?.(2)||'0.00'}</td></tr></tbody></table>`;}

function renderLeaders(){
  const leaderQB = (T) => {
    const q = T.qb?.adv || {};
    const name = T.qb ? `${T.qb.first} ${T.qb.last}` : 'QB';
    return `${T===HOME?homeLabel.value:awayLabel.value}: ${name} — ${q.comp||0}/${q.att||0}, ${q.yards||0}y, TD ${q.td||0}, INT ${q.int||0}, Sk ${q.sacks||0}`;
  };

  // Top rusher: any position (RB/QB/WR/FB) by rush yards
  const leaderRush = (T) => {
    const best = (T.players||[]).reduce((m,p)=>{
      const a = p.adv||{};
      const y = a.ry||0;
      return y > (m?.adv?.ry||0) ? p : m;
    }, null);
    if (!best) return `${T===HOME?homeLabel.value:awayLabel.value}: —`;
    const a = best.adv||{};
    return `${T===HOME?homeLabel.value:awayLabel.value}: ${best.first} ${best.last} — ${a.carries||0} rush, ${a.ry||0}y, TD ${a.td||0||0}`;
  };

  // Top receiver: WR/TE/RB by receiving yards
  const leaderRecv = (T) => {
    const elig = (T.wr||[]).concat(T.te||[]).concat(T.rb||[]);
    const best = elig.reduce((m,p)=>{
      const y = (p.adv?.recY)||0;
      return y > (m?.adv?.recY||0) ? p : m;
    }, null);
    if (!best) return `${T===HOME?homeLabel.value:awayLabel.value}: —`;
    const a = best.adv||{};
    return `${T===HOME?homeLabel.value:awayLabel.value}: ${best.first} ${best.last} — ${a.catches||0}/${a.targets||0}, ${a.recY||0}y, TD ${a.td||0}`;
  };

  leaders.innerHTML = [
    `<div class="small">${leaderQB(HOME)}</div>`,
    `<div class="small">${leaderQB(AWAY)}</div>`,
    `<div class="small" style="margin-top:6px">${leaderRush(HOME)}</div>`,
    `<div class="small">${leaderRush(AWAY)}</div>`,
    `<div class="small" style="margin-top:6px">${leaderRecv(HOME)}</div>`,
    `<div class="small">${leaderRecv(AWAY)}</div>`
  ].join('');
}

function renderTopEpa(){
  const el = document.getElementById('topEpa');
  if (!el) return;
  const items = epaPlays
    .slice()
    .sort((a,b)=> b.epa - a.epa)
    .slice(0,5);

  el.innerHTML = items.length
    ? items.map(p => `
        <div style="margin-bottom:6px">
          <span class="pill" style="margin-right:6px">PLAY</span>
          <span>${p.text}</span>
          <span class="small" style="display:block;color:#93a0b1">EPA ${(p.epa>=0?'+':'')}${(p.epa||0).toFixed(2)}</span>
        </div>`).join('')
    : '<span class="small" style="color:#93a0b1">— No plays yet —</span>';
}


function pushDriveStart(team,yard){
  const startEP = driveEPForState(
    { poss: team, down: 1, dist: 10, yard, qtr: (sim?.hud?.qtr||1), secs: (sim?.hud?.secs||900) },
    HOME, AWAY
  );

  drives.push({
    team,
    startY: yard,
    startEP,
    points: 0,
    driveEPA: 0,
    plays: 0,
    yards: 0,
    startQ: sim.hud.qtr,
    startT: sim.hud.secs,
    result: '',
    endY: null
  });
}

function closeDrive(result,endY){
  const d = drives.length ? drives[drives.length-1] : null;
  if(!d) return;
  d.result = result;
  d.endY   = endY;

  // elapsed time within drive
  d.time = d.startT - sim.hud.secs + (d.startQ!==sim.hud.qtr ? (15*60)*(sim.hud.qtr - d.startQ) : 0);

  // points credited to the offense on THIS drive (PAT excluded by design)
  const PTS = (result==='TD') ? 6 : (result==='FG' ? 3 : 0);
  d.points = PTS;

  // Drive EPA = points - StartEP
  d.driveEPA = +(PTS - (d.startEP||0)).toFixed(2);
}

function renderDrives(){
  feed.innerHTML = `<table class="table">
    <thead>
      <tr>
        <th>#</th><th>Team</th><th>Start</th><th>End</th>
        <th>Plays</th><th>Yards</th><th>Time</th><th>Result</th>
        <th>Start EP</th><th>Pts</th><th>Drive EPA</th>
      </tr>
    </thead>
    <tbody>
      ${drives.map((d,i)=>`
        <tr>
          <td>${i+1}</td>
          <td>${d.team}</td>
          <td>${yardText(d.startY)}</td>
          <td>${d.endY!==null?yardText(d.endY):'—'}</td>
          <td>${d.plays}</td>
          <td>${d.yards}</td>
          <td>${Math.floor((d.time||0)/60)}:${String((d.time||0)%60).padStart(2,'0')}</td>
          <td>${d.result||'—'}</td>
          <td>${(d.startEP??0).toFixed(2)}</td>
          <td>${d.points||0}</td>
          <td>${(d.driveEPA??0).toFixed(2)}</td>
        </tr>`).join('')}
    </tbody>
  </table>`;
}


let activeTab='plays';
tabPlays.onclick=()=>{activeTab='plays';tabPlays.classList.add('active');[tabScoring,tabDrives,tabAdvanced].forEach(x=>x.classList.remove('active'));renderPlays();}
tabScoring.onclick=()=>{activeTab='scoring';tabScoring.classList.add('active');[tabPlays,tabDrives,tabAdvanced].forEach(x=>x.classList.remove('active'));feed.innerHTML='';scoring.forEach(s=>{const d=document.createElement('div');d.className='item score';d.innerHTML=`<div><span class="tag">SCORE</span>${s.text}</div><div class="aux">${s.score}</div>`;feed.appendChild(d);});}
tabDrives.onclick=()=>{activeTab='drives';tabDrives.classList.add('active');[tabPlays,tabScoring,tabAdvanced].forEach(x=>x.classList.remove('active'));renderDrives();}
tabAdvanced.onclick=()=>{activeTab='advanced';tabAdvanced.classList.add('active');[tabPlays,tabScoring,tabDrives].forEach(x=>x.classList.remove('active'));renderAdvanced();}


// === Paste over your existing tryLoadPlayersCsv and populateTeamsFromCsv ===

async function tryLoadPlayersCsv(forceLocal = true){
  const tried = [];

  // small per-URL timeout so a bad remote can't stall the sequence
  const withTimeout = (p, ms=2000) =>
    Promise.race([p, new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')),ms))]);

  // ---- Build candidate URLs ----
  const tryUrls = [];

  // 1) LOCAL first (same folder as the HTML)
  try {
    tryUrls.push(new URL('players.csv', location.href).href);
    tryUrls.push(new URL('Players.csv', location.href).href);
  } catch { /* ignore */ }

  // 2) Optional URL param (?players=...) *after* local unless forceLocal === false
  if (!forceLocal && RAW_PLAYERS_PARAM) tryUrls.push(RAW_PLAYERS_PARAM);

  // 3) Optional GitHub fallback (only if you keep it enabled)
  if (!forceLocal && typeof CSV_USE_FALLBACK !== 'undefined' && CSV_USE_FALLBACK){
    tryUrls.push('https://raw.githubusercontent.com/aaronwolk00/game_sim/main/players.csv');
  }

  for (const url of tryUrls){
    tried.push(url);
    try{
      const res = await withTimeout(fetch(url, { cache:'no-store', mode:'cors' }));
      if (!res.ok) { console.warn('[CSV] HTTP', res.status, url); continue; }

      const text = await res.text();
      const rows = parseCSVSmart(text);
      if (!rows.length){ console.warn('[CSV] empty after parse', url); continue; }
      if (!('Team' in rows[0])){ console.warn('[CSV] missing "Team" col', Object.keys(rows[0]||{})); continue; }

      PLAYERS_CSV_ROWS = rows;

      const set = new Set();
      rows.forEach(r => { const t = String(r.Team||'').trim(); if (t) set.add(t); });
      TEAM_SHEETS = Array.from(set).sort();

      populateTeamsFromCsv();
      rosterStatus.textContent = `Loaded ${TEAM_SHEETS.length} teams from CSV`;

      // quick preview in the debug <pre> if present
      const out = document.getElementById('csvOut');
      if (out){
        out.textContent = `Teams found (${TEAM_SHEETS.length}):\n` + TEAM_SHEETS.join(', ');
        out.style.display = 'block';
      }

      // make available in console
      window.__CSV_ROWS = rows;
      window.__CSV_TEAMS = TEAM_SHEETS;
      return true;
    }catch(e){
      console.warn('[CSV] failed', url, e.message || e);
    }
  }

  rosterStatus.textContent = 'No players.csv found — using generated players.';
  console.warn('[CSV] all sources failed. Tried:', tried);
  return false;
}



/** Fill the dropdowns from TEAM_SHEETS (CSV teams) */
function populateTeamsFromCsv(){
  const opts = TEAM_SHEETS.map(t => `<option value="${t}">${t}</option>`).join('');
  const keepHome = homeTeamSel.value;
  const keepAway = awayTeamSel.value;

  homeTeamSel.innerHTML = opts;
  awayTeamSel.innerHTML = opts;

  // Re-select previous choices if still available
  if (TEAM_SHEETS.includes(keepHome)) homeTeamSel.value = keepHome;
  if (TEAM_SHEETS.includes(keepAway)) awayTeamSel.value = keepAway;

  // If nothing selected, pick the first entry (if any)
  if (!homeTeamSel.value && TEAM_SHEETS.length) homeTeamSel.value = TEAM_SHEETS[0];
  if (!awayTeamSel.value && TEAM_SHEETS.length) {
    // choose a different team if possible
    awayTeamSel.value = TEAM_SHEETS.find(t => t !== homeTeamSel.value) || TEAM_SHEETS[0];
  }

  const disabled = TEAM_SHEETS.length === 0;
  homeTeamSel.disabled = disabled;
  awayTeamSel.disabled = disabled;
}


/** Map a CSV row → simulator rating object */
function mapPlayersCsvRowToSim(r){
  const posRaw = String(r['Position']||'').toUpperCase().trim();
  const posMap = { HB:'RB', FB:'FB', RE:'DE', LE:'DE', SS:'S', FS:'S', LOLB:'OLB', ROLB:'OLB' };
  const pos = posMap[posRaw] || posRaw;

  const N = (x,d=70)=>Number.isFinite(+x)?+x:d;
  const avg = (...xs)=>Math.round(xs.reduce((a,b)=>a+N(b,0),0)/Math.max(1,xs.length));

  const first = r['First Name'] || '';
  const last  = r['Last Name']  || '';

  const Speed   = N(r['Speed']);           const Accel   = N(r['Acceleration']);
  const Agility = N(r['Agility']);         const Aware   = N(r['Awareness']);
  const Strength= N(r['Strength']);        const Catch   = N(r['Catching']);
  const Tackle  = N(r['Tackle']);          const PB      = N(r['Pass Block']);
  const PBP     = N(r['Pass Block Power']);const PBF     = N(r['Pass Block Finesse']);
  const RB      = N(r['Run Block']);       const RBP     = N(r['Run Block Power']);
  const RBF     = N(r['Run Block Finesse']);const Man    = N(r['Man Coverage']);
  const Zone    = N(r['Zone Coverage']);   const Press   = N(r['Press']);
  const PMoves  = N(r['Power Moves']);     const FMoves  = N(r['Finesse Moves']);
  const Shed    = N(r['Block Shedding']);  const TAS     = N(r['Throw Acc Short']);
  const TAM     = N(r['Throw Acc Mid']);   const TAD     = N(r['Throw Acc Deep']);
  const TUP     = N(r['Throw Under Pressure']);
  const TOR     = N(r['Throw On The Run']);const TPOW    = N(r['Throw Power']);
  const KPOW    = N(r['Kick Power']);      const KACC    = N(r['Kick Accuracy']);
  const Tough   = N(r['Toughness']);       const PR      = N(r['Play Recognition']);

  if (!(first||last) || !pos) return null;

  const PASS_ACC = (pos==='QB') ? avg(TAS,TAM,TAD,TUP,TOR) : 50;
  const PASS_PWR = (pos==='QB') ? TPOW : 50;
  const HANDS    = (pos==='WR'||pos==='TE'||pos==='RB') ? Catch : 50;
  const BLOCK    = (pos==='LT'||pos==='LG'||pos==='C'||pos==='RG'||pos==='RT'||pos==='OL')
                    ? avg(PB,PBP,PBF,RB,RBP,RBF) : avg(RB,PB);
  const COVER    = (pos==='CB'||pos==='S'||pos==='DB') ? avg(Man,Zone,Press) : avg(Man,Zone);
  const TEC      = avg(PB,RB,PMoves,FMoves,Shed,Press);
  const DISC     = avg(Tough,Aware,PR);

  return {
    "First Name":first, "Last Name":last, "Position":pos,
    OVR: N(r['Overall']),
    SPD:Speed, STR:Strength, AGI:Agility, INT:Aware, TEC,
    HANDS, TACK:Tackle, BLOCK, COVER, PASS_ACC, PASS_PWR,
    KICK_POW:KPOW, KICK_ACC:KACC, DISC
  };
}

/** Build a team from CSV by team name */
function teamFromCsv(teamName){
  if (!PLAYERS_CSV_ROWS) return null;
  const rows = PLAYERS_CSV_ROWS
    .filter(r => String(r[TEAM_COL] || '').trim() === teamName)
    .map(mapPlayersCsvRowToSim)
    .filter(Boolean);
  if (!rows.length) return null;
  return buildTeam(rows);
}

/* ===== Team name helpers (for URL + label → dropdown) ===== */
const normalizeTeam = (s) => String(s || '').toLowerCase().trim();

function fuzzyFindTeam(name){
  if (!name || !TEAM_SHEETS.length) return null;
  const target = normalizeTeam(name);

  // Exact match first
  const exact = TEAM_SHEETS.find(t => normalizeTeam(t) === target);
  if (exact) return exact;

  // Then fuzzy “contains” match
  return TEAM_SHEETS.find(t => {
    const tNorm = normalizeTeam(t);
    return tNorm.includes(target) || target.includes(tNorm);
  }) || null;
}



/* ===== Kickoffs & PAT ===== */
function beginKickoff(kicking, opts={}){
  // opts: { onside?: boolean }
  pendingKickoff = { kicking, onside: !!opts.onside };
}

function shouldOnsideNow(kicking){
  // Kicking team is usually the team that just scored.
  // Attempt if still trailing by ≥8 late, or ≥17 in 4Q, or under ~2:30 down ≥1 score.
  const s = sim.score, h = sim.hud;
  const kIsHome = (kicking === 'Home');
  const diff = (kIsHome ? (s.home - s.away) : (s.away - s.home));  // positive if kicking team leads
  const tLeft = (5 - h.qtr) * 900 + h.secs;

  const stillTrailing = diff < 0;
  if (!stillTrailing) return false;

  const deficit = -diff;
  if (tLeft <= 600 && deficit >= 17) return true;
  if (tLeft <= 120 && deficit >= 1) return true;
  if (tLeft <= 300 && deficit >= 9) return true;

  return false;
}

function onsideSuccessProb(){
  // Rough modern rates: 6–8% “expected”; 12–18% when truly telegraphed/late.
  return clamp(0.12 + 0.04 * Math.random(), 0.08, 0.18);
}

function doKickoff(){
  if(!pendingKickoff) return;

  const { kicking, onside: wantOnside } = pendingKickoff;
  const teamK = (kicking === 'Home' ? HOME : AWAY);
  const teamR = (kicking === 'Home' ? AWAY : HOME);
  const r = sim.rng;
  const k = teamK.k || { first:'K', last:'', KICK_POW:70, KICK_ACC:70 };

  let startY = 25, line = '', driveEPStart = 0;

  // Decide onside at runtime if not explicitly requested
  const onside = (wantOnside === true) || shouldOnsideNow(kicking);

  if (onside){
    // Simple onside mechanics
    const pRec = onsideSuccessProb();
    const recoveredByKicking = (Math.random() < pRec);

    if (recoveredByKicking){
      // Kicking team keeps it around midfield
      sim.hud.poss = kicking;
      sim.hud.down = 1; sim.hud.dist = 10; sim.hud.yard = 50 + Math.floor(4*sim.rng()); // ~50–54
      line = `${k.first} ${k.last} onside kick — RECOVERED by ${kicking} at ${yardText(sim.hud.yard)}`;
      driveEPStart = driveEPForState(
        { poss: sim.hud.poss, down:1, dist:10, yard: sim.hud.yard, qtr: sim.hud.qtr, secs: sim.hud.secs },
        HOME, AWAY
      );
      logPlay('KICKOFF', line, kicking, false, 0, 0, driveEPStart);
      pushDriveStart(sim.hud.poss, sim.hud.yard);
    } else {
      // Receiving team takes over around their 45–49
      sim.hud.poss = (kicking === 'Home' ? 'Away' : 'Home');
      sim.hud.down = 1; sim.hud.dist = 10; sim.hud.yard = 45 + Math.floor(5*sim.rng()); // 45–49
      line = `${k.first} ${k.last} onside kick — recovered by ${sim.hud.poss} at ${yardText(sim.hud.yard)}`;
      driveEPStart = driveEPForState(
        { poss: sim.hud.poss, down:1, dist:10, yard: sim.hud.yard, qtr: sim.hud.qtr, secs: sim.hud.secs },
        HOME, AWAY
      );
      logPlay('KICKOFF', line, kicking, false, 0, 0, driveEPStart);
      pushDriveStart(sim.hud.poss, sim.hud.yard);
    }
  } else {
    // Normal deep kick
    const gross = clamp(Math.round(60 + (k.KICK_POW-70)/2 + randNorm(r,0,5) - (+wind.value/5)), 50, 75);
    const touch = gross >= 65 || precip.value==='Heavy Rain' || precip.value==='Snow';

    if (touch){
      startY = 25;
      line = `${k.first} ${k.last} kicks ${gross} — touchback`;
    } else {
      const returner = (teamR.wr[0] || teamR.rb[0] || teamR.players[0]);
      const speedBoost = ((returner?.SPD||70) - 70)/6;
      const ret = clamp(Math.round(randNorm(r,24+speedBoost,6)), 10, 45);
      startY = ret;
      line = `${k.first} ${k.last} kicks ${gross} — ${returner.first} ${returner.last} returns to ${yardText(startY)}`;
    }

    // Receiving team starts a new drive
    sim.hud.poss = (kicking === 'Home' ? 'Away' : 'Home');
    sim.hud.down = 1; sim.hud.dist = 10; sim.hud.yard = startY;

    driveEPStart = driveEPForState(
      { poss: sim.hud.poss, down:1, dist:10, yard:startY, qtr: sim.hud.qtr, secs: sim.hud.secs },
      HOME, AWAY
    );
    logPlay('KICKOFF', line, kicking, false, 0, 0, driveEPStart);
    pushDriveStart(sim.hud.poss, sim.hud.yard);
  }

  pendingKickoff = null;
}


function shouldGoForTwo(team){
  const h = sim.hud, s = sim.score;
  const tLeft = (5 - h.qtr) * 900 + h.secs;
  const isQ4  = (h.qtr === 4);

  // Margin for the *scoring* team after the TD, before the try
  const margin = (team === 'Home') ? (s.home - s.away) : (s.away - s.home);

  // Default: kick. Only go for 2 when it clearly changes the possession math late.
  if (isQ4 && tLeft <= 360){ // last 6:00
    // Classic chart points when trailing
    if (margin === -8) return true;  // to get within 6
    if (margin === -5) return true;  // to get within a FG
    if (margin === -2) return true;  // to tie
  }

  // Super rare “coach’s gut” earlier in game if trailing (≈1.5%)
  if (!isQ4 && margin < 0 && Math.random() < 0.015) return true;

  return false;
}

function decidePAT(opts={}){
  if (opts.forceXP) return 'xp';
  if (opts.force2)  return 'two';
  return shouldGoForTwo(sim.hud.poss) ? 'two' : 'xp';
}


/* ===== Penalties ===== */
function chancePenalty(context){
  const refs=(+feelRefs.value)/100, crowd=(+feelCrowd.value)/100, varK=(+feelVariance.value)/100;
  const base=0.045 + 0.02*refs + 0.01*varK; if(Math.random()>base) return null;
  const preSnapBias = 0.25*refs + 0.35*crowd + (context.down>=3?0.1:0);
  if(Math.random()<preSnapBias){
    return Math.random()<0.7?{type:'False start',yards:-5,onDefense:false,preSnap:true}:{type:'Offside',yards:+5,onDefense:true,preSnap:true};
  }
  const roll=Math.random();
  if(context.isPass){
    if(roll<0.20) return {type:'Defensive holding',yards:+5,onDefense:true,autoFirst:true};
    if(roll<0.48) return {type:'DPI',yards:clamp(Math.round(randNorm(sim.rng,12+context.airDepth*0.6,6)),8,35),onDefense:true,spot:true,autoFirst:true};
    if(roll<0.58) return {type:'Roughing the passer',yards:+15,onDefense:true,autoFirst:true};
    return {type:'Offensive holding',yards:-10,onDefense:false};
  }else{
    if(roll<0.35) return {type:'Offensive holding',yards:-10,onDefense:false};
    if(roll<0.43) return {type:'Facemask',yards:+15,onDefense:true,autoFirst:true};
    return null;
  }
}

function applyPenalty(p){
  const h = sim.hud;

  // Snapshot BEFORE
  const before = { qtr:h.qtr, secs:h.secs, down:h.down, dist:Math.max(1,Math.round(h.dist)), yard:h.yard, poss:h.poss };
  const epBefore = driveEPForState(before, HOME, AWAY);
  const wpBefore = stateWP(sim.score.home, sim.score.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);

  // Count penalty
  const atkTeam=(h.poss==='Home'?HOME:AWAY).stats.team; atkTeam.pen++;

  // ---------- Enforce ----------
  if (p.preSnap){
    if (p.onDefense){
      h.yard = clamp(h.yard + 5, 0, 99);
      h.dist = Math.max(0, h.dist - 5);
      if (h.dist <= 0){ h.down = 1; h.dist = Math.min(10, 100 - h.yard); }
    } else {
      const prevDist = h.dist;
      h.yard = Math.max(0, h.yard - 5);
      h.dist = prevDist + 5;
    }
  } else {
    if (p.onDefense){
      if (p.spot){
        const toGL = Math.min(100 - h.yard, p.yards);
        h.yard = Math.min(99, h.yard + toGL);
        h.down = 1; h.dist = Math.min(10, 100 - h.yard);
      } else {
        h.yard = Math.min(99, h.yard + Math.abs(p.yards));
        if (p.autoFirst){ h.down = 1; h.dist = Math.min(10, 100 - h.yard); }
        else { h.dist = Math.max(1, h.dist - Math.abs(p.yards)); }
      }
    } else {
      // Offensive penalty from previous spot; special-case holding HTD
      let applied = Math.abs(p.yards);
      if (p.type === 'Offensive holding'){
        const prev = h.yard;
        applied = (prev < 20) ? Math.floor(prev/2) : 10;
        h.yard = Math.max(0, prev - applied);
        h.dist += applied;
        p._applied = applied;
      } else {
        h.yard = Math.max(0, h.yard - Math.abs(p.yards));
        h.dist += Math.abs(p.yards);
      }
    }
  }

  // ---------- After-state & deltas ----------
  const after = { qtr:h.qtr, secs:h.secs, down:h.down, dist:Math.max(1,Math.round(h.dist)), yard:h.yard, poss:h.poss };
  const epAfter  = driveEPForState(after, HOME, AWAY);
  const wpAfter  = stateWP(sim.score.home, sim.score.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
  const epaPenalty = +(epAfter - epBefore).toFixed(2);
  const wpdPenalty = clamp(wpAfter - wpBefore, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));

  // Text (show replay vs 1st)
  const firstNow = (h.down===1 && h.dist<=10);
  const txt = p.preSnap
    ? `${p.type} — ${p.onDefense?'+':'-'}5 ${firstNow ? '(1st down)' : '(replay down)'}`
    : `${p.type} — ${p.onDefense?'+':'-'}${(p._applied ?? Math.abs(p.yards))}${p.autoFirst?' (1st down)':' (replay down)'}`;

  // Log with DriveEP_before so add-up holds
  logPlay('PEN', txt, h.poss, false, epaPenalty, wpdPenalty, epBefore);
  return true;
}


/* ===== Start / Pause / Reset ===== */
function seedRoster(seed){const r=rngFromSeed(seed),
    F=["James","Michael","David","John","Robert","Chris","Daniel","Joseph","William","Ryan","Ethan","Noah","Logan","Lucas","Owen","Mason","Liam","Aiden","Kai","Leo","Benjamin","Samuel","Nathan","Zachary","Aaron","Adrian","Caleb","Henry","Carter","Julian","Isaac","Nathaniel","Christian","Hunter","Jeremiah","Thomas","Andrew","Oliver","Gabriel","Eli"],
    L=["Smith","Johnson","Williams","Brown","Jones","Garcia","Miller","Davis","Rodriguez","Martinez","Lee","Walker","Hall","Young","Allen","King","Wright","Scott","Green","Baker","Adams","Nelson","Carter","Mitchell","Perez","Roberts","Turner","Phillips","Campbell","Parker","Evans","Edwards","Collins","Stewart","Sanchez","Morris","Rogers","Reed","Cook","Morgan"];
    const name=()=>({first:F[Math.floor(r()*F.length)],last:L[Math.floor(r()*L.length)]});function mk(pos,b){const {first,last}=name();const z=d=>clamp(Math.round(60+d+randNorm(r,0,8)),40,99);return {"First Name":first,"Last Name":last,"Position":pos,SPD:z(b.spd),STR:z(b.str),AGI:z(b.agi),INT:z(b.int),TEC:z(b.tec),HANDS:z(b.hnd),TACK:z(b.tck),BLOCK:z(b.blk),COVER:z(b.cov),PASS_ACC:z(b.pac),PASS_PWR:z(b.ppw),KICK_POW:z(b.kpw),KICK_ACC:z(b.kac),DISC:clamp(Math.round(65+randNorm(r,0,12)),30,99)};}const B={QB:{spd:-5,str:0,agi:0,int:10,tec:8,hnd:0,tck:-10,blk:-10,cov:-10,pac:18,ppw:12,kpw:-20,kac:-20},RB:{spd:12,str:0,agi:12,int:0,tec:4,hnd:8,tck:-10,blk:-4,cov:-10,pac:-10,ppw:-10,kpw:-20,kac:-20},WR:{spd:16,str:-6,agi:14,int:0,tec:8,hnd:12,tck:-10,blk:-6,cov:-10,pac:-12,ppw:-12,kpw:-20,kac:-20},TE:{spd:2,str:6,agi:0,int:0,tec:4,hnd:8,tck:-6,blk:6,cov:-10,pac:-12,ppw:-12,kpw:-20,kac:-20},OL:{spd:-18,str:18,agi:-8,int:0,tec:10,hnd:-10,tck:-6,blk:16,cov:-10,pac:-20,ppw:-20,kpw:-20,kac:-20},DL:{spd:0,str:14,agi:0,int:0,tec:8,hnd:-6,tck:12,blk:0,cov:-6,pac:-20,ppw:-20,kpw:-20,kac:-20},LB:{spd:4,str:6,agi:2,int:2,tec:6,hnd:-6,tck:12,blk:0,cov:2,pac:-20,ppw:-20,kpw:-20,kac:-20},DB:{spd:12,str:-6,agi:10,int:2,tec:2,hnd:2,tck:2,blk:-8,cov:12,pac:-20,ppw:-20,kpw:-20,kac:-20},K:{spd:-8,str:-8,agi:-8,int:0,tec:0,hnd:0,tck:-10,blk:-10,cov:-10,pac:-20,ppw:-20,kpw:18,kac:18},P:{spd:-8,str:-8,agi:-8,int:0,tec:0,hnd:0,tck:-10,cov:-10,pac:-20,ppw:-20,kpw:18,kac:6}};const plan=[['QB',3],['RB',4],['WR',7],['TE',3],['OL',9],['DL',8],['LB',7],['DB',10],['K',1],['P',1]];const rows=[];plan.forEach(([p,c])=>{for(let i=0;i<c;i++)rows.push(mk(p,B[p]));});return rows;}

function startGame(){
  running=true; paused=false; pauseBtn.disabled=false; exportCsv.disabled=false;
  plays=[]; scoring=[]; drives=[]; pendingPAT=null; pendingKickoff=null; pendingScoreIdx=-1;
  timeouts={Home:3,Away:3}; toHome.textContent=3; toAway.textContent=3;

  twoMinUsed = { H1:false, H2:false };
  lastTimeoutCalledAt = { Home: 9999, Away: 9999 };

  // if no picks yet, pick two distinct CSV teams
  if ((!homeTeamSel.value || !awayTeamSel.value) && TEAM_SHEETS.length >= 2){
    const i = Math.floor(Math.random()*TEAM_SHEETS.length);
    let j = Math.floor(Math.random()*TEAM_SHEETS.length);
    if (i===j) j = (i+1) % TEAM_SHEETS.length;
    homeTeamSel.value = TEAM_SHEETS[i];
    awayTeamSel.value = TEAM_SHEETS[j];
  }

  HOME = null; AWAY = null;

  // If labels were typed but dropdowns are empty, sync dropdowns from labels
  if (TEAM_SHEETS.length){
    if (!homeTeamSel.value && homeLabel.value){
      const t = fuzzyFindTeam(homeLabel.value);
      if (t) homeTeamSel.value = t;
    }
    if (!awayTeamSel.value && awayLabel.value){
      const t = fuzzyFindTeam(awayLabel.value);
      if (t) awayTeamSel.value = t;
    }
  }


  if (TEAM_SHEETS.length){
    if (homeTeamSel.value) {
      HOME = teamFromCsv(homeTeamSel.value) || HOME;
      homeLabel.value = homeTeamSel.value; homeName.textContent = homeLabel.value;
    }
    if (awayTeamSel.value) {
      AWAY = teamFromCsv(awayTeamSel.value) || AWAY;
      awayLabel.value = awayTeamSel.value; awayName.textContent = awayLabel.value;
    }
  }

  // final fallback: generated rosters
  if(!HOME) HOME = buildTeam(seedRoster((seed.value||'seed')+'-H'));
  if(!AWAY) AWAY = buildTeam(seedRoster((seed.value||'seed')+'-A'));

  HOME.stats.team={plays:0,yards:0,passYds:0,rushYds:0,punts:0,fgm:0,fga:0,td:0,ints:0,downs:0,pen:0,third:{c:0,a:0},fourth:{c:0,a:0},epa:0}; HOME.drives=[];
  AWAY.stats.team={plays:0,yards:0,passYds:0,rushYds:0,punts:0,fgm:0,fga:0,td:0,ints:0,downs:0,pen:0,third:{c:0,a:0},fourth:{c:0,a:0},epa:0}; AWAY.drives=[];
  renderBox(); renderLeaders(); renderTopEpa();

  const r=rngFromSeed(seed.value||'seed');
  const receive=r()<0.5?'Home':'Away';
  sim={rng:r,score:{home:0,away:0},hud:{poss:receive,qtr:1,secs:900,down:1,dist:10,yard:25},crowd:{cap:72000,present:Math.floor(0.85*72000),mood:0}};
  wpSeries=[0.5]; wpSmooth=0.5; wpPrior=priorFromTeams(HOME,AWAY);
  fansPill.textContent=`Fans: ${sim.crowd.present.toLocaleString()}`;

  beginKickoff(receive==='Home'?'Away':'Home'); doKickoff();
  updateHUD(); updateScore(); drawWP(); renderPlays(); Field.render({hud:sim.hud});
  loop(+speed.value||0);
}


function pauseToggle(){if(!running)return;paused=!paused;pauseBtn.textContent=paused?'Resume':'Pause';if(!paused)loop(+speed.value||0);}
function hardReset(){
  // stop sim & UI buttons
  running = false;
  paused  = false;
  pauseBtn.disabled = true;
  pauseBtn.textContent = 'Pause';
  exportCsv.disabled = true;

  // clear logs/state
  plays = [];
  scoring = [];
  drives = [];
  pendingPAT = null;
  pendingKickoff = null;
  pendingScoreIdx = -1;

  // reset timeouts & update UI
  timeouts = { Home: 3, Away: 3 };
  if (toHome) toHome.textContent = 3;
  if (toAway) toAway.textContent = 3;

  // reset WP series
  wpSeries = [0.5];
  wpSmooth = 0.5;

  // Top-EPA list clear
  epaPlays = [];

  // keep rosters as-is; rebuild team aggregates & clear player event stats
  if (HOME){
    HOME.stats.team = { plays:0, yards:0, passYds:0, rushYds:0, punts:0, fgm:0, fga:0, td:0, ints:0, downs:0, pen:0,
                        third:{c:0,a:0}, fourth:{c:0,a:0}, epa:0 };
    HOME.drives = [];
    HOME.players.forEach(p => p.adv = {});
  }
  if (AWAY){
    AWAY.stats.team = { plays:0, yards:0, passYds:0, rushYds:0, punts:0, fgm:0, fga:0, td:0, ints:0, downs:0, pen:0,
                        third:{c:0,a:0}, fourth:{c:0,a:0}, epa:0 };
    AWAY.drives = [];
    AWAY.players.forEach(p => p.adv = {});
  }

  // rebuild sim HUD at game start (no kickoff pending)
  sim = {
    rng: rngFromSeed('seed'),
    score: { home:0, away:0 },
    hud:   { poss:'Home', qtr:1, secs:900, down:1, dist:10, yard:25 }
  };

  // recompute prior from the current (possibly CSV) rosters
  if (typeof priorFromTeams === 'function' && HOME && AWAY){
    wpPrior = priorFromTeams(HOME, AWAY);
  } else {
    wpPrior = 0.50;
  }

  // UI refresh
  feed.innerHTML = '';
  lastPlay.textContent = 'Last Play: —';
  updateHUD();
  updateScore();
  drawWP();
  renderBox();
  renderLeaders();
  renderTopEpa();
  Field.render({ hud: sim.hud });
}


startBtn.addEventListener('click',()=>{if(running)return;homeName.textContent=homeLabel.value||'Home';awayName.textContent=awayLabel.value||'Away';startGame();});
pauseBtn.addEventListener('click',pauseToggle);
resetBtn.addEventListener('click',hardReset);
document.addEventListener('keydown',e=>{if(e.code==='Space'){e.preventDefault();pauseToggle();}});

/* ===== Helpers ===== */
// === Clock helpers ===
function clockDrainFor(outcome, pace){
  // outcome: 'run' | 'comp' | 'incomp' | 'sack' | 'st'
  const p = clamp((pace-0.5), -0.5, 0.5); // -0.5..0.5
  switch(outcome){
    case 'run':    return clamp(Math.round(32 - 6*p), 24, 40);
    case 'comp':   return clamp(Math.round(27 - 5*p), 20, 35);
    case 'incomp': return clamp(Math.round(7  - 4*p),  4, 12);
    case 'sack':   return clamp(Math.round(18 - 3*p), 12, 25);
    case 'st':     return clamp(Math.round(18 - 2*p), 12, 24); // special teams
    default:       return 24;
  }
}

// Decide if the last play kept the clock running and what kind of runoff to use
function classifyClockContext(playText, kind, scored){
  // scored → stoppage
  if (scored) return { inBounds:false, outcome:'st' };

  const txt = String(playText || '').toLowerCase();

  if (kind === 'pass'){
    if (txt.includes('sacked'))  return { inBounds:true,  outcome:'sack' };
    if (txt.includes('incomplete')) return { inBounds:false, outcome:'incomp' };
    // NOTE: if you ever add explicit "out of bounds" text, set inBounds=false there.
    return { inBounds:true, outcome:'comp' };
  }

  if (kind === 'rush'){
    // If you ever tag OOB rushes in playText, switch inBounds to false.
    return { inBounds:true, outcome:'run' };
  }

  // Fallback
  return { inBounds:true, outcome:'run' };
}



function setFirstDownOrAdvance(yds){const h=sim.hud;if(yds>=0)h.dist-=yds;else h.dist+=(-yds);if(h.dist<=0){h.down=1;h.dist=Math.min(10,100-h.yard);}else{h.down++;}}
function kickerLeg(pow){return 45+0.7*(pow-70);}
function fgMakeProb(dist, pow, acc){
  dist = Math.min(dist, 68);
  let z = (kickerLeg(pow)-dist)/4 + (acc-70)/18;
  z -= (+wind.value/20)*0.4;
  if (+temp.value<25) z -= 0.3;
  if (precip.value==='Heavy Rain' || precip.value==='Snow') z -= 0.1;

  let p = 1/(1+Math.exp(-z));

  // Cap only true long kicks; don't suppress 30–40 yarders
  const cap = dist>=60 ? 0.20 : dist>=55 ? 0.55 : dist>=50 ? 0.70 : 1.00;
  if (dist>=50) p = Math.min(p, cap + 0.08*(acc-70)/30);

  return clamp(p, 0.02, 0.995);
}

// Yardline you need to reach to have ≥ pTarget make prob (defaults ~60%)
function fgTargetYardForProb(team, pTarget = 0.60){
  const k = team?.k || { KICK_POW:70, KICK_ACC:70 };
  let yardReq = 99; // worst case
  for (let dist = 30; dist <= 65; dist++){
    const p = fgMakeProb(dist, k.KICK_POW, k.KICK_ACC);
    if (p >= pTarget){
      const y = clamp(100 - (dist - 17), 1, 99); // dist = (100 - y) + 17
      yardReq = Math.min(yardReq, y);
    }
  }
  return yardReq;
}

// Returns +1 if HOME offense (trailing) can drain & kick last,
// -1 if AWAY offense (trailing) can do so, 0 otherwise.
function clockKillLeverage(){
  const h = sim.hud, s = sim.score;
  const tLeft = (5 - h.qtr) * 900 + h.secs;
  if (tLeft > 240) return 0;                       // only care inside 4:00

  const lead = s.home - s.away;                    // + if Home leads
  const trailingSide = lead > 0 ? 'Away' : (lead < 0 ? 'Home' : null);
  if (!trailingSide) return 0;

  // Must be the trailing team on offense and within FG deficit (≤ 2 pts)
  if (h.poss !== trailingSide || Math.abs(lead) > 2) return 0;

  const offense   = (h.poss === 'Home') ? HOME : AWAY;
  const defenseTO = timeouts[(h.poss === 'Home') ? 'Away' : 'Home'] || 0;

  // Field-goal “target line” for ~60% make in current weather/wind
  const needY = fgTargetYardForProb(offense, 0.60);
  const yardsToTarget = Math.max(0, needY - h.yard);

  // How many safe run plays until kick (rough): if 1st/2nd → ~3 plays, else ~2
  const playsToKick = (h.down <= 2 ? 3 : 2);

  // Realistic drain per run including setup/runoff (decreased by TOs)
  const burn = playsToKick * 36 - defenseTO * 18;  // ~36s each; TO ≈ 18s swing

  const canMilk  = (burn >= tLeft - 8);            // can kick with <8s remaining
  const canReach = (h.yard >= needY) || (yardsToTarget <= (h.down <= 2 ? 12 : 6));

  if (canMilk && canReach){
    return (h.poss === 'Home') ? +1 : -1;
  }
  return 0;
}


function fgEPA(FGdist,epBefore,yard){const k=(sim.hud.poss==='Home'?HOME:AWAY).k||{KICK_POW:70,KICK_ACC:70};const p=fgMakeProb(FGdist,k.KICK_POW,k.KICK_ACC);const epAfterMiss=-EP(1,10,clamp(100-yard,1,99));return 3*p+epAfterMiss*(1-p)-epBefore;}
function pickDefender(def,role){const pool= role==='sack'?(def.dl.concat(def.lb)) : role==='int'?def.db.concat(def.lb): role==='tacklePass'?def.db.concat(def.lb): def.dl.concat(def.lb); return pool[Math.floor(sim.rng()*pool.length)]||{first:'Def',last:'ender',adv:{}};}

// ---- Play snapshot & header helpers ----
function snapshotHUD(){
  const h = sim.hud;
  return {
    qtr: h.qtr,
    secs: h.secs,
    down: h.down,
    dist: Math.max(1, Math.round(h.dist)),
    yard: h.yard,
    poss: h.poss
  };
}
function headerFrom(snap){
  return `Q${snap.qtr} ${Math.floor(snap.secs/60)}:${String(snap.secs%60).padStart(2,'0')} | ${dnTxt(snap.down)} & ${snap.dist} @ ${yardText(snap.yard)}`;
}
function chooseReceiver(atk){const r=sim.rng(); let group=null;if(r<0.65&&atk.wr.length)group=atk.wr;else if(r<0.85&&atk.te.length)group=atk.te;else group=atk.rb.length?atk.rb:atk.wr;return group[Math.floor(sim.rng()*group.length)]||atk.qb;}

function pickRusher(atk, h){
  const pool = [];
  const rb1 = atk.rb?.[0], rb2 = atk.rb?.[1], rb3 = atk.rb?.[2];
  const qb  = atk.qb;
  const wr  = (atk.wr && atk.wr.length) ? atk.wr[Math.floor(sim.rng()*atk.wr.length)] : null;
  const fb  = (atk.players||[]).find(p => p.pos === 'FB') || null;
  const short = h.dist <= 2;

  const fatigueDrop = p => (p && (p.adv?.carries||0) > 22) ? 0.6 : 1.0;

  if (rb1) pool.push([rb1, 0.55 * fatigueDrop(rb1)]);
  if (rb2) pool.push([rb2, 0.30 * fatigueDrop(rb2)]);
  if (rb3) pool.push([rb3, 0.12 * fatigueDrop(rb3)]);

  // WR jet/end-around ~3%
  if (wr) pool.push([wr, 0.03]);

  // FB dive very occasional
  if (fb) pool.push([fb, 0.03]);

  // QB sneak/keeper weight: bigger on short yardage and for mobile QBs
  if (qb){
    const mobile = (qb.SPD||70) >= 82;
    let w = mobile ? 0.06 : 0.03;
    if (short) w += mobile ? 0.12 : 0.06;
    pool.push([qb, w]);
  }

  const total = pool.reduce((a,[,w]) => a+w, 0) || 1;
  let x = sim.rng()*total;
  for (const [p,w] of pool){
    x -= w; if (x <= 0) return p;
  }
  return rb1 || qb || wr || (atk.players?.[0]); // ultimate fallback
}


// ===== Crowd helpers (GLOBAL) =====
function computeCrowdIntensity(){
  const c = sim?.crowd || {present:0, cap:1, mood:0};
  const h = sim?.hud || {down:1, dist:10, yard:25, qtr:1, secs:900};
  const att = clamp(c.present / (c.cap || 1), 0, 1);
  const mood = clamp(c.mood || 0, -1, 1); // -1..1

  // Baseline + situational boosts (so it's not 0 unless stadium empty)
  let ctx = 0.15;                                              // baseline hum
  if ((h.down===3 && h.dist<=5) || h.down===4) ctx += 0.25;   // big down
  if (h.yard>=80) ctx += 0.15;                                // red zone
  if (h.qtr===2 && h.secs<=120) ctx += 0.08;                  // late 1H
  if (h.qtr===4){ ctx += 0.10; if (h.secs<=300) ctx += 0.10;} // late 4Q
  if (Math.abs(sim.score.home - sim.score.away)<=8) ctx += 0.10; // one-score
  ctx = clamp(ctx, 0, 1);

  const base = att * (0.7 + 0.3 * mood);
  return clamp(base * ctx, 0, 1); // 0..1
}

function renderCrowdMeter(){
  const x = computeCrowdIntensity();     // 0..1
  const pct = (x*100);
  crowdPct.textContent = pct.toFixed(1) + '%';     // ← show decimal
  crowdBar.style.width = pct + '%';
}

function updateCrowd(){
  const h = sim.hud, c = sim.crowd; if(!c) return;
  const cap = c.cap || 72000;

  // Arrivals: 85% at kick, remaining 15% over first 12 min of Q1
  let target = c.present;
  if (h.qtr === 1) {
    const elapsed = 900 - h.secs;
    const arrivals = Math.round(0.15 * cap * Math.min(1, elapsed / 720));
    target = Math.floor(0.85 * cap + arrivals);
  }

  // Departures by score/weather/time
  const diff = Math.abs(sim.score.home - sim.score.away);
  const homeTrailing = (sim.score.home < sim.score.away);
  let leaveRate = 0;
  if (h.qtr >= 3 && diff >= 17) leaveRate += 0.005 * (diff - 16);
  if (precip.value === 'Heavy Rain' || precip.value === 'Snow') leaveRate += 0.004;
  if (+temp.value <= 20) leaveRate += 0.003;
  if (homeTrailing && h.qtr === 4 && h.secs < 600 && diff >= 10) leaveRate += 0.006;

  // Late, close games → hype
  if (h.qtr === 4 && diff <= 3) {
    leaveRate = Math.max(0, leaveRate - 0.004);
    c.mood = Math.min(1, (c.mood || 0) + 0.02);
  } else {
    c.mood = Math.max(-1, (c.mood || 0) - 0.005);
  }

  const desired = Math.max(0, Math.min(cap, target - Math.floor(cap * leaveRate)));
  c.present = Math.round(0.9 * c.present + 0.1 * desired);
  fansPill.textContent = `Fans: ${c.present.toLocaleString()}`;
  renderCrowdMeter();
}

function calcPlayTime(isScored){
  const h = sim.hud;
  const s = sim.score;
  const tf = clamp(1 - ((5 - h.qtr)*900 + h.secs)/3600, 0, 1);

  // get pace here (it was causing a ReferenceError before)
  const pace = (+feelPace.value)/100;

  // baseline
  let t = clamp(
    Math.round(
      randNorm(
        sim.rng,
        26 + (precip.value!=='None'?2:0) - 4*(pace-0.5),
        4
      )
    ),
    18, 35
  );

  // hurry-up if trailing late
  const homeTrail = (s.home < s.away);
  const trailTeam = homeTrail ? 'Home' : ((s.away < s.home) ? 'Away' : null);
  const trailingLate = (!!trailTeam) && (tf > 0.72);

  if (trailingLate){
    t = Math.max(16, Math.round(t * 0.78)); // ~22% faster
  }

  // after a score keep it compact; PAT/kickoff timing handled elsewhere
  if (isScored) t = Math.max(18, Math.min(28, t));

  return t;
}



/* ===== Main loop ===== */
function loop(ms){
  const r=sim.rng,h=sim.hud,s=sim.score;
  (async function tick(){
    while(running&&!paused){
        if(pendingKickoff){
            doKickoff(); updateHUD(); updateScore(); Field.render({hud:h});
            const t=stateWP(s.home,s.away,h.qtr,h.secs,h.yard,h.poss,wpPrior);
            wpSmooth=0.97*wpSmooth+0.03*t; wpSeries.push(wpSmooth);
            wpVal.textContent=(wpSmooth*100).toFixed(1)+'%'; drawWP();
            updateCrowd(); // ← added
            if(ms>0) await new Promise(rs=>setTimeout(rs,ms));
            continue;
            }
      if(pendingPAT){
        const {team, type} = pendingPAT;
        const atk = (team==='Home'?HOME:AWAY);
        const def = (team==='Home'?AWAY:HOME);
        const k   = atk.k || {first:'K',last:'',KICK_ACC:70};

        // WP *before* attempting the PAT (after TD but pre-PAT)
        const wpBeforePAT = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);

        let text = '', realizedPts = 0, expectedPts = 0;

        if (type==='xp'){
          const xpP = clamp(0.93 + (k.KICK_ACC-70)/250 - (+wind.value/20)*0.08 - ((precip.value==='Heavy Rain'||precip.value==='Snow')?0.04:0), 0.85, 0.99);
          const make = sim.rng() < xpP;
          realizedPts = make ? 1 : 0; expectedPts = xpP;

          if (make){ if(team==='Home') s.home += 1; else s.away += 1; }
          text = `XP — ${k.first} ${k.last} ${make?'GOOD':'NO GOOD'}`;
        } else {
          const twoP = clamp(0.48 + (atk.offense - def.defense)/220, 0.35, 0.63);
          const make = sim.rng() < twoP;
          realizedPts = make ? 2 : 0; expectedPts = 2*twoP;

          if (make){ if(team==='Home') s.home += 2; else s.away += 2; }
          text = `2-pt Try — ${make?'GOOD':'FAIL'}`;
        }

        const epaPAT = realizedPts - expectedPts;

        // WP after PAT result (score now updated)
        const wpAfterPAT = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
        const wpdPAT = clamp(wpAfterPAT - wpBeforePAT, -0.12, 0.12);

        if (pendingScoreIdx>=0){
          const e = scoring[pendingScoreIdx];
          e.text += (type==='xp' ? ` (XP ${realizedPts? 'good':'no good'})` : ` (2-pt ${realizedPts? 'good':'fail'})`);
          e.score = `${s.home}-${s.away}`;
        }

        logPlay('PLAY', text, team, true, epaPAT, wpdPAT, 0);

        applyClock(0, { inBounds:false, offense: team, pat:true });
        pendingPAT = null;
        beginKickoff(team, { onside: shouldOnsideNow(team) });;

        updateHUD(); updateScore(); Field.render({hud:h});
        const t = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
        wpSmooth = 0.97*wpSmooth + 0.03*t; wpSeries.push(wpSmooth);
        wpVal.textContent = (wpSmooth*100).toFixed(1)+'%'; drawWP();
        updateCrowd();
        if (ms>0) await new Promise(rs=>setTimeout(rs,ms));
        continue;
      }

    // Pre-snap penalty check happens BEFORE we snapshot EP/WP
    const pre = chancePenalty({ down: h.down, isPass: false, airDepth: 0 });
    if (pre && pre.preSnap) {
      applyPenalty(pre);
      updateHUD(); Field.render({ hud:h });
      if (ms > 0) await new Promise(rs => setTimeout(rs, ms));
      continue;       // replay down from new spot, then we'll re-snapshot next loop
    }

    // snapshot AFTER pre-snap penalties are cleared, BEFORE any play logic
    const snap = snapshotHUD();
    const ep0 = driveEPForState(snap, HOME, AWAY); // decision-aware EP_before
    const wp0 = stateWP(s.home, s.away, snap.qtr, snap.secs, snap.yard, snap.poss, wpPrior);
    const startPoss = snap.poss;
    const driveEP0 = driveEPForState(snap, HOME, AWAY);

      /* >>> Early 4th-down decision: if not going for it, do FG/Punt here and stop <<< */
        if (h.down === 4) {
        const distGL = 100 - h.yard;
        const FGdist = Math.round(distGL + 17);
        const aggr = (+aggr4th.value);
        const goThresh = (h.yard >= 50 ? 4.0 : 2.0) - (aggr - 50)/25 - (h.qtr === 4 ? 0.6 : 0);

        if (h.dist > goThresh) {
            // Not going for it → choose FG if reasonable, else punt. Log ONLY that play.
            const teamObj = (h.poss === 'Home' ? HOME : AWAY).stats.team;
            const k = (h.poss === 'Home' ? HOME : AWAY).k;

            if (k && FGdist <= 68 && h.dist > 1) {
                // ΔWP: snapshot before we mutate score/possession
                const wpBefore = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);

                teamObj.fga++;
                const make = Math.random() < fgMakeProb(FGdist, k.KICK_POW, k.KICK_ACC);

                if (make) {
                  teamObj.fgm++;
                  if (h.poss === 'Home') s.home += 3; else s.away += 3;

                  const epaFG = 3 - ep0;

                  // WP after: scoring updated, possession unchanged (kickoff is pending)
                  const wpAfter = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
                  const wpdFG   = clamp(wpAfter - wpBefore, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));

                  scoring.push({ text: `${h.poss} FG (${FGdist})`, score: `${s.home}-${s.away}` });
                  logPlay('PLAY', `${headerFrom(snap)} — FG — ${k.first} ${k.last} GOOD from ${FGdist}`,h.poss, true, epaFG, wpdFG, driveEP0);

                  closeDrive('FG', h.yard);
                  beginKickoff(h.poss, { onside: shouldOnsideNow(h.poss) });;
                } else {
                  // Miss → opponent ball at 100 - yard
                  const newForDef = clamp(100 - h.yard, 1, 99);
                  const epaFG = 0 - ep0;

                  // Mutate to the missed-FG state BEFORE computing wpAfter
                  closeDrive('Missed FG', h.yard);
                  h.poss = (h.poss === 'Home' ? 'Away' : 'Home'); h.down = 1; h.dist = 10; h.yard = newForDef;
                  pushDriveStart(h.poss, h.yard);

                  const wpAfter = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
                  const wpdFG   = clamp(wpAfter - wpBefore, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));

                  logPlay('PLAY', `${headerFrom(snap)} — FG — ${k.first} ${k.last} NO GOOD from ${FGdist}`, snap.poss, false, epaFG, wpdFG, driveEP0);
                }
              }
            else {
              // Punt (early 4th-down block)
              const wpBefore = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);

              const punter = (h.poss === 'Home' ? HOME : AWAY).p || { first:'P', last:'', KICK_POW:70 };
              const gross = clamp(Math.round(46 + (punter.KICK_POW - 70)/2 + randNorm(sim.rng,0,7)), 35, 70);
              const land  = h.yard + gross;

              let text = '';
              if (land >= 100) {
                text = `${headerFrom(snap)} — Punt ${gross} by ${punter.first} ${punter.last} — touchback`;
                (h.poss==='Home'?HOME:AWAY).stats.team.punts++;
                closeDrive('Punt (TB)', h.yard);

                // flip
                h.poss = (h.poss === 'Home' ? 'Away' : 'Home'); h.down = 1; h.dist = 10; h.yard = 20;
                pushDriveStart(h.poss, h.yard);
              } else {
                const retMan = ((h.poss === 'Home' ? AWAY : HOME).wr[0] || (h.poss === 'Home' ? AWAY : HOME).rb[0] || (h.poss === 'Home' ? AWAY : HOME).players[0]);
                const recvAt = 100 - land;
                const ret    = clamp(Math.round(randNorm(sim.rng,10,8)), 0, 40);
                const end    = clamp(recvAt + ret, 1, 99);
                text = `${headerFrom(snap)} — Punt ${gross} by ${punter.first} ${punter.last}, ${retMan.first} ${retMan.last} returns ${ret} to ${yardText(end)}`;

                (h.poss==='Home'?HOME:AWAY).stats.team.punts++;
                closeDrive('Punt', h.yard);

                // flip
                h.poss = (h.poss === 'Home' ? 'Away' : 'Home'); h.down = 1; h.dist = 10; h.yard = end;
                pushDriveStart(h.poss, h.yard);
              }

              const wpAfter = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
              const wpdPunt = clamp(wpAfter - wpBefore, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));

              logPlay('PLAY', text, snap.poss, false, -ep0, wpdPunt, driveEP0);
            }


            // consume a bit of clock for special teams, render, and skip normal play
            applyClock(clockDrainFor('st', (+feelPace.value)/100), { inBounds:true, offense: snap.poss });

            updateHUD(); updateScore(); Field.render({ hud:h });
            const t = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
            wpSmooth = 0.97*wpSmooth + 0.03*t; wpSeries.push(wpSmooth);
            wpVal.textContent = (wpSmooth*100).toFixed(1) + '%'; if (wpSeries.length>600) wpSeries.shift();
            drawWP(); renderBox(); renderLeaders(); renderTopEpa(); updateCrowd();

            if (h.secs<=0){
            h.qtr++; if(h.qtr<=4){ h.secs=900; beginKickoff('Away'); }
            else { running=false; pauseBtn.disabled=true; logPlay('FINAL',`FINAL: ${homeLabel.value} ${s.home} – ${awayLabel.value} ${s.away}`,'Home',true,0,0); }
            }
            if (ms>0) await new Promise(rs=>setTimeout(rs,ms));
            continue; // ← critical: prevents a run/pass from also occurring on 4th down
        }
        }

      const atk=(h.poss==='Home'?HOME:AWAY), def=(h.poss==='Home'?AWAY:HOME);
      const offAdv=atk.offense-def.defense, varK=(+feelVariance.value)/100;
      const passPref=(h.qtr<=2?+passEarly.value:+passLate.value)/100;
      const thirdLong=(h.down===3 && h.dist>=7);

      // new: anchor near NFL rates, then tweak by situation
      let passRate = 0.52 + (passPref - 0.55)*0.55;          // coach bias but bounded
      if (h.down>=3) passRate += 0.12;
      if (h.dist>=7) passRate += 0.06;
      if (s.home < s.away) passRate += 0.05;                 // trailing → pass a bit more
      if (s.home > s.away && h.qtr>=4) passRate -= 0.08;     // protect lead late
      passRate = clamp(passRate, 0.38, 0.64);

      const runRate = 1 - passRate;

      let deltaY=0, kind='', scored=false, playText='';
      const playTime = calcPlayTime(scored);

      if (r() < runRate){
        const runner = pickRusher(atk, h);

        let ppen = chancePenalty({ down: h.down, isPass: false, airDepth: 0 });
        // No DPI on runs — convert to defensive holding 5y, auto 1st
        if (ppen && !ppen.preSnap && ppen.type === 'DPI') {
          ppen = { type:'Defensive holding', yards:+5, onDefense:true, autoFirst:true };
        }
        if (ppen) {
          applyPenalty(ppen);
          updateHUD(); Field.render({ hud:h });
          if (ms > 0) await new Promise(rs => setTimeout(rs, ms));
          continue;
        }

        const isQB = (runner === atk.qb);
        // NFL-ish yard distributions
        let mean   = 3.9 + offAdv*0.025;
        let spread = 3.2*(1 + 0.6*varK);
        if (isQB && h.dist <= 2){ mean = 2.3; spread = 1.4; }            // QB sneak/keeper
        else if (isQB){ mean = 5.2 + (runner.SPD-78)/18; spread = 2.8; } // scramble-like keepers

        const yRaw = clamp(Math.round(randNorm(r, mean, spread)), -4, 35);
        const yds  = Math.min(yRaw, 100 - h.yard);
        const tack = pickDefender(def,'tackleRun');

        if (h.yard + yds >= 100){
          if (h.poss === 'Home') s.home += 6; else s.away += 6;
          scored = true; kind = 'rush';
          playText = `${runner.first} ${runner.last} rushes for ${yds} yards, TOUCHDOWN`;
          atk.stats.team.td++;

          // TD logging (pre-PAT), then set pendingPAT (will suppress the generic logger later)
          const kAcc = ((h.poss==='Home'?HOME:AWAY).k?.KICK_ACC ?? 70);
          const xpP  = clamp(0.93 + (kAcc-70)/250 - (+wind.value/20)*0.08 - ((precip.value==='Heavy Rain'||precip.value==='Snow')?0.04:0), 0.85, 0.99);
          const tdEPA = 6 - ep0;
          const wpAfterTD = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
          const wpdTD = clamp(wpAfterTD - wp0, -0.30, 0.30);
          logPlay('PLAY', `${headerFrom(snap)} — ${playText}`, snap.poss, true, tdEPA, wpdTD, 0);

          const twoP = clamp(0.48 + (atk.offense - def.defense)/220, 0.35, 0.63);
          const patType = decidePAT({});
          pendingPAT = { team: h.poss, type: patType, exp: (patType==='xp' ? xpP : 2*twoP) };
          pendingScoreIdx = scoring.push({ text: `${h.poss} TD run`, score: `${s.home}-${s.away}` }) - 1;
          closeDrive('TD', 100);
        } else {
          h.yard = clamp(h.yard + yds, 0, 99);
          deltaY = yds; kind = 'rush';
          setFirstDownOrAdvance(yds);
          tack.adv.tkl = (tack.adv.tkl||0) + (h.yard+yds>=100?0:1);
          playText = `${runner.first} ${runner.last} rushes for ${yds} yards, tackled by ${tack.first} ${tack.last} at ${yardText(h.yard)}`;
        }

        // Stats
        runner.adv.carries = (runner.adv.carries||0)+1;
        runner.adv.ry      = (runner.adv.ry||0) + Math.max(0, yds);
        const mph = clamp(13 + (runner.SPD-70)/3 + randNorm(r,0,1.5), 11, 22);
        runner.adv.fast = Math.max(runner.adv.fast||0, mph);

        atk.stats.team.rushYds += Math.max(0, deltaY);
      } else {
                // PASS
                const qb=atk.qb ? atk.qb : {first:'QB',last:'',PASS_ACC:70,INT:70,adv:{att:0,comp:0,yards:0,td:0,int:0,sacks:0,dropbacks:0,pressures:0,ttt:0,tttN:0,air:0,yac:0}};
        if(!qb.adv) qb.adv={};
        qb.adv.dropbacks=(qb.adv.dropbacks||0)+1;

        const air = clamp(Math.round(randNorm(r, 6 + offAdv*0.008, 5*(1+0.5*varK))), -1, 26);
        const pen = chancePenalty({ down: h.down, isPass: true, airDepth: air });
        if (pen) {
        if (pen.preSnap) {
            // Pre-snap penalty: NO PLAY. Enforce and replay down from previous spot.
            applyPenalty(pen);
        } else {
            // Live-ball penalty (e.g., holding/DPI): NO RESULT. Enforce from previous spot and replay.
            applyPenalty(pen);
        }
        updateHUD(); Field.render({ hud: h });
        if (ms > 0) await new Promise(rs => setTimeout(rs, ms));
        continue; // <- critical: never run the play on any penalty
        }

        // Pressure → possible scramble → else resolve (sack / complete / incomplete)
        const pressureP = clamp(0.24 + (def.defense - atk.offense) / 180, 0.12, 0.45);
        const pressured  = (r() < pressureP);
        if (pressured) qb.adv.pressures = (qb.adv.pressures || 0) + 1;

        /* ---- QB SCRAMBLE (when pressured) ----
          Mobile QBs (higher SPD) and long yardage slightly increase scramble rate. */
        const scrambleP = clamp(
          0.08 + (qb.SPD - 78) / 120 + (pressured ? 0.10 : 0) + (h.dist >= 8 ? 0.03 : 0),
          0.02, 0.28
        );

        if (pressured && r() < scrambleP) {
          // Treat as a run: do NOT count as a pass attempt
          const y = Math.min(
            clamp(Math.round(randNorm(r, 7 + (qb.SPD - 80) / 8, 4.5)), -2, 35),
            100 - h.yard
          );

          if (h.yard + y >= 100) {
            if (h.poss === 'Home') s.home += 6; else s.away += 6;
            scored = true; kind = 'rush';
            playText = `${qb.first} ${qb.last} scrambles ${y} yards for a TOUCHDOWN`;
            atk.stats.team.td++;

            // Log TD pre-PAT and set pendingPAT
            const kAcc = ((h.poss==='Home'?HOME:AWAY).k?.KICK_ACC ?? 70);
            const xpP  = clamp(0.93 + (kAcc-70)/250 - (+wind.value/20)*0.08 - ((precip.value==='Heavy Rain'||precip.value==='Snow')?0.04:0), 0.85, 0.99);
            const tdEPA = 6 - ep0;
            const wpAfterTD = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
            const wpdTD = clamp(wpAfterTD - wp0, -0.30, 0.30);
            logPlay('PLAY', `${headerFrom(snap)} — ${playText}`, snap.poss, true, tdEPA, wpdTD, 0);

            const twoP = clamp(0.48 + (atk.offense - def.defense)/220, 0.35, 0.63);
            const patType = decidePAT({});
            pendingPAT = { team: h.poss, type: patType, exp: (patType==='xp' ? xpP : 2*twoP) };
            pendingScoreIdx = scoring.push({ text: `${h.poss} TD run (QB scramble)`, score: `${s.home}-${s.away}` }) - 1;
            closeDrive('TD', 100);
          } else {
            h.yard = clamp(h.yard + y, 0, 99);
            deltaY = y; kind = 'rush';
            setFirstDownOrAdvance(y);
            const tack = pickDefender(def, 'tackleRun'); tack.adv.tkl = (tack.adv.tkl||0) + 1;
            playText = `${qb.first} ${qb.last} scrambles for ${y} yards, tackled by ${tack.first} ${tack.last} at ${yardText(h.yard)}`;
            qb.adv.carries = (qb.adv.carries||0) + 1;
            qb.adv.ry      = (qb.adv.ry||0) + Math.max(0, y);
            atk.stats.team.rushYds += Math.max(0, y);
          }

        } else {
          // ---- Pure pass resolution (no scramble) ----
          const sackP = pressured ? 0.18 : 0.06;
          const expComp = clamp(
            0.58 + (qb.PASS_ACC - 80) / 220
                - (def.defense - 70) / 300
                - (air > 12 ? 0.09 : 0)
                - (pressured ? 0.08 : 0),
            0.42, 0.72
          );

          qb.adv.expSum = (qb.adv.expSum || 0) + expComp;
          qb.adv.expN   = (qb.adv.expN   || 0) + 1;

          const ttt = clamp(randNorm(r, 2.65 + (pressured ? -0.3 : 0), 0.35), 1.3, 4.5);
          qb.adv.ttt  = (qb.adv.ttt  || 0) + ttt;
          qb.adv.tttN = (qb.adv.tttN || 0) + 1;

          const x = r();
          if (x < sackP) {
            const loss = clamp(Math.round(randNorm(r, 6, 3)), 3, 13);
            const sacker = pickDefender(def, 'sack');
            sacker.adv.sk = (sacker.adv.sk || 0) + 1;
            h.yard = Math.max(0, h.yard - loss);
            deltaY = -loss; kind = 'pass';
            setFirstDownOrAdvance(-loss);
            playText = `${qb.first} ${qb.last} sacked by ${sacker.first} ${sacker.last} for -${loss} at ${yardText(h.yard)}`;
            qb.adv.sacks = (qb.adv.sacks || 0) + 1;

          } else {
            if (r() < expComp) {
              const wr  = chooseReceiver(atk);
              const yac = Math.max(0, Math.round(randNorm(r, 3.0 + (atk.offense - def.defense)/140, 2.2*(1+0.5*varK))));
              // Cap total gain by yards-to-goal
              const gain = Math.min(Math.max(0, air) + yac, 100 - h.yard);

              if (h.yard + gain >= 100) {
                if (h.poss === 'Home') s.home += 6; else s.away += 6;
                scored = true; kind = 'pass';
                playText = `${qb.first} ${qb.last} completes to ${wr.first} ${wr.last} for ${gain} yards, TOUCHDOWN`;
                atk.stats.team.td++;

                // TD logging (pre-PAT)
                const kAcc = ((h.poss==='Home'?HOME:AWAY).k?.KICK_ACC ?? 70);
                const xpP  = clamp(0.93 + (kAcc-70)/250 - (+wind.value/20)*0.08 - ((precip.value==='Heavy Rain'||precip.value==='Snow')?0.04:0), 0.85, 0.99);
                const tdEPA = 6 - ep0;
                const wpAfterTD = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
                const wpdTD = clamp(wpAfterTD - wp0, -0.30, 0.30);
                logPlay('PLAY', `${headerFrom(snap)} — ${playText}`, snap.poss, true, tdEPA, wpdTD, 0);

                const twoP = clamp(0.48 + (atk.offense - def.defense)/220, 0.35, 0.63);
                const patType = decidePAT({});
                pendingPAT = { team: h.poss, type: patType, exp: (patType==='xp' ? xpP : 2*twoP) };
                pendingScoreIdx = scoring.push({ text: `${h.poss} TD pass`, score: `${s.home}-${s.away}` }) - 1;
                closeDrive('TD', 100);

                // Stats
                qb.adv.td    = (qb.adv.td||0) + 1;
                qb.adv.comp  = (qb.adv.comp||0) + 1; qb.adv.att = (qb.adv.att||0) + 1;
                qb.adv.yards = (qb.adv.yards||0) + gain; qb.adv.air += Math.max(0, air); qb.adv.yac += yac;
                wr.adv.catches = (wr.adv.catches||0) + 1; wr.adv.targets = (wr.adv.targets||0) + 1;
                wr.adv.recY = (wr.adv.recY||0) + gain; wr.adv.air = (wr.adv.air||0) + Math.max(0, air);
                wr.adv.yac = (wr.adv.yac||0) + yac; wr.adv.td = (wr.adv.td||0) + 1;

              } else {
                h.yard = clamp(h.yard + gain, 0, 99);
                deltaY = gain; kind = 'pass';
                setFirstDownOrAdvance(gain);
                const tack = pickDefender(def, 'tacklePass'); tack.adv.tkl = (tack.adv.tkl||0) + 1;
                playText = `${qb.first} ${qb.last} completes to ${wr.first} ${wr.last} for ${gain} yards, tackled by ${tack.first} ${tack.last} at ${yardText(h.yard)}`;

                wr.adv.targets = (wr.adv.targets||0) + 1; wr.adv.catches = (wr.adv.catches||0) + 1;
                wr.adv.recY = (wr.adv.recY||0) + gain; wr.adv.air = (wr.adv.air||0) + Math.max(0, air);
                wr.adv.yac = (wr.adv.yac||0) + yac; wr.adv.ayDepth = (wr.adv.ayDepth||0) + Math.max(0, air);
                wr.adv.ayN = (wr.adv.ayN||0) + 1;
                const sep = clamp(2.7 + (wr.SPD - 70) / 25 - (def.defense - 70) / 120 + randNorm(r, 0, 0.6), 0.5, 4.5);
                wr.adv.sep = (wr.adv.sep||0) + sep; wr.adv.sepN = (wr.adv.sepN||0) + 1;

                qb.adv.comp  = (qb.adv.comp||0) + 1; qb.adv.att = (qb.adv.att||0) + 1;
                qb.adv.yards = (qb.adv.yards||0) + gain; qb.adv.air += Math.max(0, air); qb.adv.yac += yac;
              }

            } else {
              // incomplete or INT chance
              if (r() < 0.04) {
                const pick = pickDefender(def, 'int'); pick.adv.ints = (pick.adv.ints||0) + 1;
                const ret  = clamp(Math.round(randNorm(r, 10, 7)), 0, 60);
                const newForDef = clamp(100 - (h.yard + ret), 1, 99);
                playText = `${qb.first} ${qb.last} pass is INTERCEPTED by ${pick.first} ${pick.last}, return to ${yardText(newForDef)}`;
                (h.poss==='Home'?HOME:AWAY).stats.team.ints++;
                closeDrive('INT', h.yard);
                h.poss = (h.poss === 'Home' ? 'Away' : 'Home'); h.down = 1; h.dist = 10; h.yard = newForDef;
                pushDriveStart(h.poss, h.yard);
              } else {
                setFirstDownOrAdvance(0);
                const db = pickDefender(def, 'tacklePass'); db.adv.pd = (db.adv.pd||0) + 1;
                playText = `${qb.first} ${qb.last} pass incomplete`;
                qb.adv.att = (qb.adv.att||0) + 1;
                const wrMiss = chooseReceiver(atk); wrMiss.adv.targets = (wrMiss.adv.targets||0) + 1;
                if (r() < clamp(0.03 + (70 - (wrMiss.HANDS||70)) / 400, 0.01, 0.08)) {
                  wrMiss.adv.drops = (wrMiss.adv.drops||0) + 1; playText += ' (drop)';
                }
              }
            }
          }

          // Only passes contribute to team.passYds
          if (kind === 'pass') {
            atk.stats.team.passYds += Math.max(0, deltaY);
          }
        }
      }

      // Update team/drives
      const teamObj=(startPoss==='Home'?HOME:AWAY).stats.team;
      if(startPoss===h.poss){ teamObj.plays++; teamObj.yards+=deltaY; }
      const D=drives.length?drives[drives.length-1]:null;
      if(D && startPoss===h.poss){ D.plays++; D.yards+=deltaY; }

      if (startPoss === h.poss && snap.down === 3) {
        teamObj.third.a++;
        if (h.down === 1) {
          teamObj.third.c++;
        }
      }

      // clock — outcome-aware drain (run/comp/incomp/sack) + late OOB bias
      {
        const pace = (+feelPace.value)/100;
        const ctx = classifyClockContext(playText, kind, scored);

        // late-game sideline bias: occasionally force clock to stop on in-bounds gains
        if (!scored) {
          const offenseIsHome = (startPoss === 'Home');
          const lead = sim.score.home - sim.score.away;
          const offenseTrailing = offenseIsHome ? (lead < 0) : (lead > 0);
          const tLeft = (5 - h.qtr) * 900 + h.secs;
          const late = (h.qtr === 4) && (tLeft <= 300);
          const oobBias = late && offenseTrailing ? 0.18 : 0.06;
          const wentOOB = (kind !== 'sack') && (Math.random() < oobBias);
          if (wentOOB) ctx.inBounds = false;
        }

        applyClock(clockDrainFor(ctx.outcome, pace), { inBounds: ctx.inBounds, offense: startPoss });
      }


      // 4th down decisions (go-for-it resolution only; FG/punts handled earlier)
      if (!scored && h.down === 5) {
        const distGL  = 100 - h.yard;
        const FGdist  = Math.round(distGL + 17); // kept for potential future use
        const aggr    = (+aggr4th.value);
        const goThresh = (h.yard >= 50 ? 4.0 : 2.0) - (aggr - 50)/25 - (h.qtr === 4 ? 0.6 : 0);

        // Only handle true "go for it" situations here.
        if (h.dist <= goThresh) {
          teamObj.fourth.a++;
          const wpBefore = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);

          const atkTeam  = (h.poss === 'Home' ? HOME : AWAY);
          const defTeam  = (h.poss === 'Home' ? AWAY : HOME);
          const success  = Math.random() < clamp(
            0.48 + (atkTeam.offense - defTeam.defense)/220,
            0.30,
            0.70
          );

          if (success) {
            teamObj.fourth.c++;
            h.down = 1;
            h.dist = Math.min(10, 100 - h.yard);

            const wpAfter = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
            const wpdGo   = clamp(wpAfter - wpBefore, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));
            logPlay('PLAY','4th-down conversion — chains move', h.poss, false, 0, wpdGo);
          } else {
            teamObj.downs++;
            closeDrive('Downs', h.yard);

            // Flip on downs at spot
            const newForDef = clamp(100 - h.yard, 1, 99);
            const prevPoss  = h.poss;

            h.poss = (h.poss === 'Home' ? 'Away' : 'Home');
            h.down = 1;
            h.dist = 10;
            h.yard = newForDef;
            pushDriveStart(h.poss, h.yard);

            const wpAfter = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);
            const wpdFail = clamp(wpAfter - wpBefore, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));
            logPlay('PLAY','4th-down failed — turnover on downs', prevPoss, false, -ep0, wpdFail);
          }
        }
      }


      // EPA/WP annotate and log with the PRE-PLAY header (drive-EP consistent)
      const wp1 = stateWP(s.home, s.away, h.qtr, h.secs, h.yard, h.poss, wpPrior);

      // decision-aware EP_after for current offense state
      const ep1Drive = driveEPForState(
        { poss:h.poss, down:h.down, dist:h.dist, yard:h.yard, qtr:h.qtr, secs:h.secs },
        HOME, AWAY
      );

      // If the play scored, realized drive points are 6 (TD) or 3 (FG); else ΔEP
      const realizedPts = scored ? 6 : 0;   // (FG/Punt handled in the special-teams blocks below)
      const epa = scored ? (realizedPts - ep0) : (ep1Drive - ep0);

      // ΔWP cap by time
      const wpd = clamp(wp1 - wp0, -wpCap(h.qtr, h.secs), wpCap(h.qtr, h.secs));


      // DriveEP: post-play EP, but if a TD just occurred,
      let driveEpForLog = null;
      if (scored && pendingPAT && typeof pendingPAT.exp === 'number') {
        driveEpForLog = pendingPAT.exp;             // (<= 1 for XP, <= 2 for two-point)
      } else if (!scored) {
        driveEpForLog = clamp(EP(h.down, h.dist, h.yard), 0, 6.99);
      }

      // Log once
      if (!pendingKickoff && !pendingPAT) {
        logPlay('PLAY', `${headerFrom(snap)} — ${playText}`, startPoss, scored, epa, wpd, driveEP0);
      }


      (h.poss==='Home'?HOME:AWAY).stats.team.epa += (epa||0);

      // visuals
      updateHUD(); updateScore(); Field.render({hud:h});
      wpSmooth=0.97*wpSmooth+0.03*wp1; wpSeries.push(wpSmooth);
      wpVal.textContent=(wpSmooth*100).toFixed(1)+'%';
      if(wpSeries.length>600) wpSeries.shift();
      drawWP(); renderBox(); renderLeaders(); renderTopEpa();

      if(h.secs<=0){
        h.qtr++;
        if(h.qtr<=4){ h.secs=900; beginKickoff('Away'); }
        else { running=false; pauseBtn.disabled=true; logPlay('FINAL',`FINAL: ${homeLabel.value} ${s.home} – ${awayLabel.value} ${s.away}`,'Home',true,0,0); break; }
      }

      if(ms>0) await new Promise(rs=>setTimeout(rs,ms));
    }
  })();
}


/* ===== Advanced Tab (team + players) ===== */
function renderAdvanced(){
  const teamTable = (name,T)=>{
    const qb=T.qb?.adv||{}; const epaP=(T.stats.team.epa/(T.stats.team.plays||1)).toFixed(2); const db=qb.dropbacks||0, pr=db?(qb.pressures/db*100).toFixed(1):'0.0'; const ttt=qb.tttN?(qb.ttt/qb.tttN).toFixed(2):'0.00'; const cpoe= qb.expN?(((qb.comp||0)/qb.expN - qb.expSum/qb.expN)*100).toFixed(1):'0.0'; const adot = recAgg(T).adot.toFixed(1), yacPer=recAgg(T).yacPer.toFixed(1), topSpeed=(T.players||[]).reduce((m,p)=>Math.max(m,p.adv?.fast||0),0).toFixed(1);
    return `<tr><th>${name}</th><td>${epaP}</td><td>${db}</td><td>${pr}%</td><td>${ttt}</td><td>${cpoe}%</td><td>${adot}</td><td>${yacPer}</td><td>${topSpeed}</td></tr>`;
  };
  const recAgg = (T)=>{let targets=0,air=0,yac=0,catches=0;(T.wr||[]).concat(T.te||[]).concat(T.rb||[]).forEach(p=>{const a=p.adv||{};targets+=a.targets||0;catches+=a.catches||0;air+=a.air||0;yac+=a.yac||0;});return {adot:targets?air/targets:0,yacPer:catches?yac/catches:0};};

  const teamHTML = `
  <div class="small" style="margin-bottom:6px">Team Advanced</div>
  <table class="table"><thead><tr><th></th><th>EPA/play</th><th>Dropbacks</th><th>Pressure%</th><th>TTT (s)</th><th>CPOE</th><th>aDOT</th><th>YAC/rec</th><th>Top speed (mph)</th></tr></thead>
  <tbody>${teamTable(homeLabel.value,HOME)}${teamTable(awayLabel.value,AWAY)}</tbody></table>`;

  const playersHTML = renderPlayersTables();
  feed.innerHTML = teamHTML + '<div class="line"></div>' + playersHTML;
}
function renderPlayersTables(){
  const rowsQBs = (T)=> T.qb?[T.qb]:[]; const rowsRBs = (T)=> T.rb||[]; const rowsWRs = (T)=> (T.wr||[]).concat(T.te||[]); const rowsDEF = (T)=> (T.dl||[]).concat(T.lb||[]).concat(T.db||[]);
  const fmt=(n)=> (n??0);

  const qbTable = (teamName,T)=>`<div class="small" style="margin-top:6px">${teamName} — Quarterbacks</div>
    <table class="table"><thead><tr><th>Name</th><th>C/Att</th><th>Yds</th><th>TD</th><th>INT</th><th>Sacks</th><th>DB</th><th>Press%</th><th>TTT</th><th>CPOE</th></tr></thead>
    <tbody>${rowsQBs(T).map(q=>{const a=q.adv||{};const db=a.dropbacks||0,pr=db?((a.pressures||0)/db*100).toFixed(1):'0.0';const ttt=a.tttN? (a.ttt/a.tttN).toFixed(2):'0.00';const cpoe=a.expN?(((a.comp||0)/a.expN - a.expSum/a.expN)*100).toFixed(1):'0.0';return `<tr><td>${q.first} ${q.last}</td><td>${fmt(a.comp)}/${fmt(a.att)}</td><td>${fmt(a.yards)}</td><td>${fmt(a.td)}</td><td>${fmt(a.int)}</td><td>${fmt(a.sacks)}</td><td>${db}</td><td>${pr}%</td><td>${ttt}</td><td>${cpoe}%</td></tr>`;}).join('')}</tbody></table>`;

  const rbTable = (teamName,T)=>`<div class="small" style="margin-top:6px">${teamName} — Rushers</div>
    <table class="table"><thead><tr><th>Name</th><th>Att</th><th>Yds</th><th>TD</th><th>Top mph</th></tr></thead>
    <tbody>${rowsRBs(T).map(p=>{const a=p.adv||{};return `<tr><td>${p.first} ${p.last}</td><td>${fmt(a.carries)}</td><td>${fmt(a.ry)}</td><td>${fmt(a.td)}</td><td>${(a.fast||0).toFixed(1)}</td></tr>`;}).join('')}</tbody></table>`;

  const wrTable = (teamName,T)=>`<div class="small" style="margin-top:6px">${teamName} — Receivers</div>
    <table class="table"><thead><tr><th>Name</th><th>Tgt</th><th>Rec</th><th>Yds</th><th>TD</th><th>aDOT</th><th>YAC/rec</th><th>Drops</th><th>Sep</th><th>Top mph</th></tr></thead>
    <tbody>${rowsWRs(T).map(p=>{const a=p.adv||{};const adot=a.ayN?(a.ayDepth/a.ayN).toFixed(1):'0.0';const yac=a.catches? (a.yac/a.catches).toFixed(1):'0.0';const sep=a.sepN? (a.sep/a.sepN).toFixed(1):'0.0';return `<tr><td>${p.first} ${p.last}</td><td>${fmt(a.targets)}</td><td>${fmt(a.catches)}</td><td>${fmt(a.recY)}</td><td>${fmt(a.td)}</td><td>${adot}</td><td>${yac}</td><td>${fmt(a.drops)}</td><td>${sep}</td><td>${(a.fast||0).toFixed(1)}</td></tr>`;}).join('')}</tbody></table>`;

  const defTable = (teamName,T)=>`<div class="small" style="margin-top:6px">${teamName} — Defense</div>
    <table class="table"><thead><tr><th>Name</th><th>Tkl</th><th>Sacks</th><th>INT</th><th>PD</th></tr></thead>
    <tbody>${rowsDEF(T).map(p=>{const a=p.adv||{};return `<tr><td>${p.first} ${p.last}</td><td>${fmt(a.tkl)}</td><td>${fmt(a.sk)}</td><td>${fmt(a.ints)}</td><td>${fmt(a.pd)}</td></tr>`;}).join('')}</tbody></table>`;

  return qbTable(homeLabel.value,HOME)+qbTable(awayLabel.value,AWAY)
       + rbTable(homeLabel.value,HOME)+rbTable(awayLabel.value,AWAY)
       + wrTable(homeLabel.value,HOME)+wrTable(awayLabel.value,AWAY)
       + defTable(homeLabel.value,HOME)+defTable(awayLabel.value,AWAY);
}

/* ===== Export ===== */
function exportBlob(name,data,type){const b=new Blob([data],{type});const url=URL.createObjectURL(b);const a=document.createElement('a');a.href=url;a.download=name;document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url);}
exportCsv.onclick = () => {
  const lines = ['tag,offense,line,scoring,epa,delta_wp,drive_ep'];
  plays.forEach(p => {
    const safeLine = (p.line || '').replace(/"/g, '""');
    const scoringFlag = p.scoring ? '1' : '0';
    const epa = Number.isFinite(p.epa) ? p.epa.toFixed(3) : '';
    const dwp = Number.isFinite(p.wpd) ? p.wpd.toFixed(4) : '';
    const dep = Number.isFinite(p.driveEp) ? p.driveEp.toFixed(3) : '';

    lines.push([
      p.tag,
      p.off || '',
      `"${safeLine}"`,
      scoringFlag,
      epa,
      dwp,
      dep
    ].join(','));
  });
  exportBlob('play_log.csv', lines.join('\n'), 'text/csv');
};


/* ===== Init (CSV only) ===== */
(async function init(){
  startBtn.disabled = true;

  // safe boot visuals before rosters exist
  try{
    sim = {
      rng: rngFromSeed('seed'),
      score: { home:0, away:0 },
      hud:   { poss:'Home', qtr:1, secs:900, down:1, dist:10, yard:25 }
    };
    Field.render({ hud: sim.hud });
    updateHUD(); updateScore(); drawWP(); renderBox(); renderLeaders(); renderTopEpa(); renderCrowdMeter();
  }catch{}

  // helper to pick two distinct teams if URLs are missing/bad
  function pickTwoDistinct(list){
    if (!list || list.length < 2) return [list?.[0] || '', list?.[0] || ''];
    const i = Math.floor(Math.random()*list.length);
    let j = Math.floor(Math.random()*list.length);
    if (j === i) j = (i+1) % list.length;
    return [list[i], list[j]];
  }

  try{
    // If ?players= is present, try that FIRST (so index.html → game.html works),
    // then local; otherwise do local first, then remote.
    let loaded = false;
    const haveParamCsv = !!RAW_PLAYERS_PARAM;

    if (haveParamCsv){
      // try param / remote path first
      loaded = await tryLoadPlayersCsv(false);   // tries ?players= then fallback
      if (!loaded) loaded = await tryLoadPlayersCsv(true);  // then local
    } else {
      // no param → behave like before (local first)
      loaded = await tryLoadPlayersCsv(true);    // local
      if (!loaded) loaded = await tryLoadPlayersCsv(false); // then fallback
    }

    if (loaded && TEAM_SHEETS.length){
      // Respect ?home=&away= from index.html
      const hFromUrl = fuzzyFindTeam(URL_HOME);
      const aFromUrl = fuzzyFindTeam(URL_AWAY);

      let homeT = hFromUrl;
      let awayT = aFromUrl;

      if (!homeT && !awayT){
        [homeT, awayT] = pickTwoDistinct(TEAM_SHEETS);
      } else if (!homeT){
        homeT = TEAM_SHEETS.find(t => t !== awayT) || TEAM_SHEETS[0];
      } else if (!awayT || awayT === homeT){
        awayT = TEAM_SHEETS.find(t => t !== homeT) || TEAM_SHEETS[0];
      }

      // Reflect in dropdowns AND labels immediately (no manual clicking)
      homeTeamSel.value = homeT; homeLabel.value = homeT; homeName.textContent = homeT;
      awayTeamSel.value = awayT; awayLabel.value = awayT; awayName.textContent = awayT;

      rosterStatus.textContent = `Loaded ${TEAM_SHEETS.length} teams from CSV`;
    } else {
      rosterStatus.textContent = 'No players.csv found — using generated players.';
    }
  }catch(e){
    console.error('init failed:', e);
    rosterStatus.textContent = 'Roster load error — using generated players.';
  }finally{
    startBtn.disabled = false;
  }
})();


</script>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NFL Sim — League Standings</title>
<style>
:root{--bg:#0b1220;--panel:#121a2a;--card:#0e1630;--text:#eef2ff;--muted:#93a0b1;--accent:#5eead4}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:grid;place-items:center}
main{width:min(980px,94vw);display:grid;gap:16px}
h1{margin:0 0 6px;font-size:22px;letter-spacing:.2px}
.panel{background:var(--panel);border-radius:14px;padding:12px;border:1px solid #1c2440;box-shadow:0 6px 24px rgba(0,0,0,.25)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.btn{display:inline-flex;align-items:center;justify-content:center;padding:10px 12px;border-radius:10px;background:var(--accent);color:#0a0f17;font-weight:700;font-size:14px;border:none;box-shadow:0 2px 0 rgba(0,0,0,.25);text-decoration:none}
.btn.ghost{background:var(--card);color:#dbe3ef;border:1px solid #2a355a;box-shadow:none}
.small{font-size:12px;color:var(--muted)}
hr{height:1px;background:#1c2440;border:0;margin:6px 0;border-radius:2px}
.table{width:100%;border-collapse:collapse;font-size:13px}
.table th,.table td{border-bottom:1px solid #1f2740;padding:8px 8px;text-align:left}
.table th{font-weight:700;color:#dbe3ef}
.right{text-align:right}
.section{background:rgba(255,255,255,.02);border:1px solid #1c2440;border-radius:12px;padding:8px;margin-top:8px}
.section h3{margin:0 0 6px;font-size:14px}
.pill{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--card);border:1px solid #233055;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <main>
    <div class="row" style="justify-content:space-between;align-items:center">
      <h1>League Standings</h1>
      <div class="row">
        <a id="backLink" class="btn ghost">← Weekly Games</a>
        <a id="toSchedule" class="btn">Schedule</a>
        <a id="toSimSeason" class="btn">▶ Sim Season</a>
        <span id="livePill" class="pill">Live: idle</span>
      </div>
    </div>

    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <span class="pill" id="teamCount">— teams</span>
        <span class="pill" id="csvPill">Players CSV: loading…</span>
      </div>
      <hr>
      <div id="standings"></div>
    </div>

    <div class="small">
      If a sim is running in another tab, this page updates in real time.
      If you only sim individual games in the Schedule view, those results
      are stored locally and also shown here as standings.
    </div>
  </main>

<script>
/* ========= Params ========= */
const PARAMS = new URLSearchParams(location.search);
const RAW_PLAYERS_PARAM  = (PARAMS.get('players')  || '').replace('/refs/heads/', '/');
const RAW_SCHEDULE_PARAM = (PARAMS.get('schedule') || '').replace('/refs/heads/', '/');

const playersParamStr = RAW_PLAYERS_PARAM ? `players=${encodeURIComponent(RAW_PLAYERS_PARAM)}` : '';
const schedParamStr   = RAW_SCHEDULE_PARAM ? `schedule=${encodeURIComponent(RAW_SCHEDULE_PARAM)}` : '';
const join = (...parts)=> parts.filter(Boolean).join('&');
const both = join(playersParamStr, schedParamStr);
const qs = both ? `?${both}` : (playersParamStr ? `?${playersParamStr}` : '');

document.getElementById('toSchedule').href = `schedule.html${qs}`;
document.getElementById('toSimSeason').href = `sim_season.html${qs}`;
document.getElementById('backLink').href = `index.html${playersParamStr ? `?${playersParamStr}` : ''}`;

/* ========= Sources ========= */
const CSV_URLS = RAW_PLAYERS_PARAM
  ? [RAW_PLAYERS_PARAM, new URL('players.csv', location.href).href, 'https://raw.githubusercontent.com/aaronwolk00/game_sim/refs/heads/main/players.csv']
  : [new URL('players.csv', location.href).href, 'https://raw.githubusercontent.com/aaronwolk00/game_sim/refs/heads/main/players.csv'];

/* ========= DOM ========= */
const csvPill = document.getElementById('csvPill');
const teamCount = document.getElementById('teamCount');
const livePill = document.getElementById('livePill');
const elStandings = document.getElementById('standings');

/* ========= Keys & Live wiring ========= */
const LIVE_KEY_STANDINGS = 'simSeason:2020:standings';
const LOCAL_RESULTS_KEY  = 'headlessResults';

let KNOWN_TEAM_NAMES = [];
let HAS_LIVE_SEASON  = false;

const chan = new BroadcastChannel('nfl-sim-2020');
chan.onmessage = (evt)=>{
  const { type, standings, progress, results } = evt.data || {};

  if(type === 'reset'){
    livePill.textContent='Live: starting…';
    return;
  }

  if(type === 'standings' && standings){
    // full-season sim broadcast (engine)
    HAS_LIVE_SEASON = true;
    livePill.textContent = progress ? `Live: ${progress.done}/${progress.total}` : 'Live: update';
    applyHeadlessResults(standings); // overlay any stored single-game results
    const rows = Object.values(standings).sort((a,b)=>
      (b.wins-a.wins) ||
      ((b.pf-b.pa)-(a.pf-a.pa)) ||
      a.team.localeCompare(b.team)
    );
    elStandings.innerHTML = tableStandingsHTML(rows);
    try{
      localStorage.setItem(LIVE_KEY_STANDINGS, JSON.stringify(standings));
    }catch(e){}
    return;
  }

  if(type === 'complete'){
    livePill.textContent='Live: complete';
    return;
  }

  if(type === 'headlessResultsUpdated'){
    // schedule.html is telling us local game results changed
    if (results) {
      try{
        localStorage.setItem(LOCAL_RESULTS_KEY, JSON.stringify(results));
      }catch(e){}
    }
    // if a full-season sim is running, don't override it
    if (!HAS_LIVE_SEASON){
      renderLocalStandingsIfAny();
      livePill.textContent = 'Live: local games';
    }
  }
};

/* ========= Local results helpers ========= */
function loadLocalResults(){
  try{
    return JSON.parse(localStorage.getItem(LOCAL_RESULTS_KEY) || '{}');
  }catch(e){
    return {};
  }
}

function computeStandingsFromResults(teamNames, results){
  const standings = {};
  // initialize every known team
  (teamNames || []).forEach(t=>{
    standings[t] = { team:t, wins:0, losses:0, pf:0, pa:0 };
  });

  for (const k in results){
    const g = results[k];
    if (!g) continue;
    const home = g.home;
    const away = g.away;
    const hp = Number(g.homePts);
    const ap = Number(g.awayPts);
    if (!home || !away) continue;
    if (!Number.isFinite(hp) || !Number.isFinite(ap)) continue;

    if (!standings[home]) standings[home] = { team:home, wins:0, losses:0, pf:0, pa:0 };
    if (!standings[away]) standings[away] = { team:away, wins:0, losses:0, pf:0, pa:0 };

    standings[home].pf += hp; standings[home].pa += ap;
    standings[away].pf += ap; standings[away].pa += hp;

    if (hp > ap){
      standings[home].wins++; standings[away].losses++;
    }else if (ap > hp){
      standings[away].wins++; standings[home].losses++;
    }
  }
  return standings;
}

function renderLocalStandingsIfAny(){
  if (!KNOWN_TEAM_NAMES.length) return;
  const results = loadLocalResults();
  const keys = Object.keys(results);
  if (!keys.length) return;

  const standings = computeStandingsFromResults(KNOWN_TEAM_NAMES, results);
  const rows = Object.values(standings).sort((a,b)=>
    (b.wins-a.wins) ||
    ((b.pf-b.pa)-(a.pf-a.pa)) ||
    a.team.localeCompare(b.team)
  );
  elStandings.innerHTML = tableStandingsHTML(rows);
}

/* ========= CSV helpers ========= */
async function fetchCsvText(){
  let lastErr = null;
  for (const url of CSV_URLS){
    try{
      const res = await fetch(url, { cache: 'no-store', mode: 'cors' });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const txt = await res.text();
      return { txt, url };
    }catch(e){ lastErr = e; }
  }
  throw lastErr || new Error('CSV not reachable');
}
function parseCsvToRows(text){
  text = String(text || '').replace(/^\uFEFF/, '');
  const rows=[]; let row=[], field='', inQ=false;
  for(let i=0;i<text.length;i++){
    const c=text[i];
    if(inQ){
      if(c==='"'){ if(text[i+1]==='"'){ field+='"'; i++; } else inQ=false; }
      else field+=c;
    }else{
      if(c==='"') inQ=true;
      else if(c===','){ row.push(field); field=''; }
      else if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; }
      else if(c!=='\r'){ field+=c; }
    }
  }
  row.push(field); rows.push(row);
  while(rows.length && rows[rows.length-1].every(x => String(x||'').trim()==='')) rows.pop();
  return rows.filter(r=>r.length && r.some(x=>x!==''));;
}
function findHeaderIndex(rows){
  const norm = s => String(s||'').trim().toLowerCase();
  for(let i=0;i<Math.min(rows.length,8);i++){
    if(rows[i].some(c => norm(c)==='team')) return i;
  }
  return 0;
}
function rowsToObjects(rows, headerIdx){
  const header = rows[headerIdx].map(h => String(h||'').trim());
  return rows.slice(headerIdx+1).map(r => { const o={}; header.forEach((h,j)=> o[h]= r[j]===undefined ? '' : r[j]); return o; });
}

/* ========= Ratings ========= */
function toNum(x, d=70){ const v=Number(x); return Number.isFinite(v) ? v : d; }
function playerOVR(p){
  if (p.OVR !== undefined && p.OVR !== '') return toNum(p.OVR, 70);
  const keys = ['SPD','STR','AGI','INT','TEC','HANDS','TACK','BLOCK','COVER','PASS_ACC','PASS_PWR'];
  let sum=0, n=0;
  keys.forEach(k => { const v = toNum(p[k], NaN); if (Number.isFinite(v)){ sum+=v; n++; } });
  return n? (sum/n) : 70;
}
function rateTeams(objs){
  const byTeam = new Map();
  objs.forEach(r => {
    const t=String(r.Team||'').trim();
    if(!t) return;
    if(!byTeam.has(t)) byTeam.set(t,[]);
    byTeam.get(t).push(r);
  });
  return Array.from(byTeam.entries()).map(([team,rows])=>{
    const vals = rows.map(playerOVR);
    const rating = Math.round(vals.reduce((a,b)=>a+b,0)/vals.length);
    return { team, rating };
  });
}

/* ========= Rendering ========= */
function tableStandingsHTML(rows){
  return `
    <table class="table">
      <thead>
        <tr>
          <th>#</th><th>Team</th>
          <th class="right">W</th><th class="right">L</th>
          <th class="right">PF</th><th class="right">PA</th>
          <th class="right">Diff</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map((r,i)=>`
          <tr>
            <td class="right">${i+1}</td>
            <td>${r.team}</td>
            <td class="right">${r.wins}</td>
            <td class="right">${r.losses}</td>
            <td class="right">${r.pf}</td>
            <td class="right">${r.pa}</td>
            <td class="right">${r.pf - r.pa}</td>
          </tr>`).join('')}
      </tbody>
    </table>`;
}
function tableRatingsHTML(rows){
  return `
    <table class="table">
      <thead><tr><th>#</th><th>Team</th><th class="right">Rating</th></tr></thead>
      <tbody>
        ${rows.map((t,i)=>`
          <tr>
            <td class="right">${i+1}</td>
            <td>${t.team}</td>
            <td class="right">${t.rating}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>`;
}

/* ========= Apply local headless results on top of season standings ========= */
function applyHeadlessResults(standings){
  const data = loadLocalResults();
  for (const k in data){
    const g = data[k];
    const home = g.home, away = g.away;
    const hp = +g.homePts, ap = +g.awayPts;
    if (!home || !away) continue;
    if (!standings[home]) standings[home] = { team: home, wins:0, losses:0, pf:0, pa:0 };
    if (!standings[away]) standings[away] = { team: away, wins:0, losses:0, pf:0, pa:0 };
    standings[home].pf += hp; standings[home].pa += ap;
    standings[away].pf += ap; standings[away].pa += hp;
    if (hp > ap){ standings[home].wins++; standings[away].losses++; }
    else if (ap > hp){ standings[away].wins++; standings[home].losses++; }
  }
}

/* ========= Boot ========= */
(async function init(){
  // 1) Try to show last known full-season standings from sim_season
  try{
    const cached = localStorage.getItem(LIVE_KEY_STANDINGS);
    if(cached){
      const stand = JSON.parse(cached);
      HAS_LIVE_SEASON = true;
      applyHeadlessResults(stand);
      const rows = Object.values(stand).sort((a,b)=>
        (b.wins-a.wins) ||
        ((b.pf-b.pa)-(a.pf-a.pa)) ||
        a.team.localeCompare(b.team)
      );
      elStandings.innerHTML = tableStandingsHTML(rows);
      livePill.textContent = 'Live: cached';
    }
  }catch(e){}

  // 2) Load players.csv → know teams, show rating-based baseline if nothing else
  try{
    const { txt, url } = await fetchCsvText();
    csvPill.textContent = `Players CSV: ${url.includes('githubusercontent')?'remote':'local'}`;

    const rows = parseCsvToRows(txt);
    const headerIdx = findHeaderIndex(rows);
    const objs = rowsToObjects(rows, headerIdx);

    const teams = rateTeams(objs);
    teamCount.textContent = `${teams.length} teams`;
    KNOWN_TEAM_NAMES = teams.map(t => t.team);

    // if we *don't* already have standings from a live / cached season,
    // try to render standings from local single-game results
    if (!HAS_LIVE_SEASON){
      renderLocalStandingsIfAny();
    }

    // If we still have nothing rendered, fall back to rating order.
    if(!elStandings.innerHTML){
      const ordered = teams.sort((a,b)=> b.rating - a.rating || a.team.localeCompare(b.team));
      elStandings.innerHTML = tableRatingsHTML(ordered);
      livePill.textContent = 'Live: idle';
    }
  }catch(e){
    console.error(e);
    csvPill.textContent = 'Players CSV: error';
    if(!elStandings.innerHTML){
      elStandings.innerHTML = `<div class="small" style="color:#fca5a5">
        Could not load <code>players.csv</code>. Waiting for live sim or local results…
      </div>`;
    }
  }
})();
</script>
</body>
</html>

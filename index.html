<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Layer 3 – Team Rosters</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --card: #020617;
      --card-border: #1e293b;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #22c55e;
      --accent-soft: rgba(34,197,94,0.15);
      --danger: #f97373;
      --font: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
              "Segoe UI", Roboto, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at top, #0b1120 0, #020617 48%, #020617 100%);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    main {
      width: min(1080px, 96vw);
      margin: 24px 0 40px;
    }
    h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.03em;
      display: flex;
      align-items: baseline;
      gap: 10px;
    }
    h1 span.sub {
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
      text-transform: uppercase;
    }
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #1f2937;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
    }
    .status-pill .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #fbbf24;
    }
    .status-pill.ready .dot { background: #22c55e; }
    .status-pill.error .dot { background: var(--danger); }
    .status-pill strong { color: var(--text); }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .search-input {
      background: #020617;
      border-radius: 999px;
      border: 1px solid #1f2937;
      padding: 6px 10px;
      color: var(--text);
      font-size: 13px;
      min-width: 180px;
    }
    .search-input::placeholder {
      color: #6b7280;
    }
    .btn {
      border: none;
      outline: none;
      cursor: pointer;
      border-radius: 999px;
      padding: 7px 11px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-weight: 600;
      background: var(--accent-soft);
      color: #bbf7d0;
      border: 1px solid rgba(34,197,94,0.45);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .btn:hover {
      background: rgba(34,197,94,0.28);
    }

    .summary-bar {
      margin: 6px 0 18px;
      font-size: 13px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .teams-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    details.team-card {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 14px;
      border: 1px solid var(--card-border);
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      transition: border-color 0.12s ease, background 0.12s ease;
    }
    details.team-card[open] {
      border-color: rgba(34,197,94,0.5);
      background: radial-gradient(circle at top left, rgba(34,197,94,0.18), rgba(15,23,42,0.95));
    }
    summary.team-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      list-style: none;
    }
    summary.team-header::-webkit-details-marker {
      display: none;
    }
    .team-name-block {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .team-name {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .team-meta {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .roster-meta {
      font-size: 11px;
      color: var(--muted);
    }

    .roster-table-wrapper {
      margin-top: 8px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      overflow: hidden;
      background: rgba(15, 23, 42, 0.95);
    }
    table.roster-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    table.roster-table thead {
      background: rgba(15, 23, 42, 1);
    }
    table.roster-table th,
    table.roster-table td {
      padding: 6px 8px;
      border-bottom: 1px solid #1f2937;
      text-align: left;
      white-space: nowrap;
    }
    table.roster-table th {
      font-weight: 600;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-size: 11px;
    }
    table.roster-table tbody tr:nth-child(even) {
      background: rgba(15, 23, 42, 0.75);
    }
    table.roster-table tbody tr:last-child td {
      border-bottom: none;
    }

    .empty-message {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }

    .error-text {
      color: var(--danger);
      font-size: 13px;
      margin-top: 8px;
    }

    @media (max-width: 640px) {
      .team-name {
        font-size: 14px;
      }
      table.roster-table th:nth-child(4),
      table.roster-table td:nth-child(4) {
        display: none; /* hide last name on very small screens */
      }
    }

    /* === Sortable roster tables & light interactivity === */
    table.roster-table.sortable th {
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    table.roster-table th .sort-icon {
      margin-left: 6px;
      font-size: 10px;
      opacity: .55;
    }
    table.roster-table th[aria-sort="ascending"] .sort-icon::after { content: "▲"; }
    table.roster-table th[aria-sort="descending"] .sort-icon::after { content: "▼"; }
    table.roster-table th[aria-sort="none"] .sort-icon::after { content: "◇"; opacity: .35; }

    /* Click-to-select a row */
    table.roster-table tbody tr:hover {
      background: rgba(34,197,94,0.12);
    }
    table.roster-table tbody tr.row-selected {
      outline: 2px solid var(--accent);
      background: var(--accent-soft);
    }

  </style>
</head>
<body>
  <main>
    <div class="top-row">
      <div>
        <h1>
          Layer 3 Rosters
          <span class="sub">from layer3_rosters.csv</span>
        </h1>
        <div id="status-pill" class="status-pill">
          <span class="dot"></span>
          <span><strong>Loading</strong> rosters…</span>
        </div>
      </div>

      <!-- controls now include Simulation button -->
      <div class="controls">
        <input
          id="search-input"
          class="search-input"
          type="search"
          placeholder="Filter by team name or ID…" />
        <button id="btn-clear" class="btn" type="button">Clear</button>
        <!-- NEW: Simulation button -->
        <a id="btn-sim" class="btn" href="#">Simulation</a>
        <a id="btn-batch" class="btn" href="#">Batch Sim</a>
      </div>
    </div>

    <div class="summary-bar">
      <span id="summary-text">Reading CSV…</span>
      <span id="source-text"></span>
    </div>

    <div id="error-box" class="error-text" style="display:none;"></div>
    <div id="teams-container" class="teams-container"></div>
  </main>

  <script>
    // ---------------------------- Config --------------------------------------
    const PARAMS = new URLSearchParams(location.search);

    // Allow ?players=<url> override; otherwise default to your Layer 3 roster URL.
    const RAW_PLAYERS_PARAM = (PARAMS.get('players') || '').replace('/refs/heads/', '/');
    const DEFAULT_LAYER3_URL =
      'https://raw.githubusercontent.com/aaronwolk00/game_sim/refs/heads/main/layer3_rosters.csv';

    const EFFECTIVE_ROSTER_URL = RAW_PLAYERS_PARAM || DEFAULT_LAYER3_URL;

    const CSV_URLS = [
      EFFECTIVE_ROSTER_URL,
      DEFAULT_LAYER3_URL
    ];

    // ------------------------ DOM lookup helpers ------------------------------
    const dom = {
      statusPill: document.getElementById('status-pill'),
      summaryText: document.getElementById('summary-text'),
      sourceText: document.getElementById('source-text'),
      teamsContainer: document.getElementById('teams-container'),
      errorBox: document.getElementById('error-box'),
      searchInput: document.getElementById('search-input'),
      btnClear: document.getElementById('btn-clear'),
      btnSim: document.getElementById('btn-sim'), // <-- NEW
      btnBatch: document.getElementById('btn-batch')
    };

    function setStatus(state, msg) {
      // state: 'loading' | 'ready' | 'error'
      const pill = dom.statusPill;
      if (!pill) return;
      pill.classList.remove('ready', 'error');
      const dot = pill.querySelector('.dot');
      const span = pill.querySelector('span:last-child');

      if (state === 'loading') {
        span.innerHTML = `<strong>Loading</strong> rosters…`;
        if (dot) dot.style.background = '#fbbf24';
      } else if (state === 'error') {
        pill.classList.add('error');
        span.innerHTML = `<strong>Error</strong> ${msg || ''}`;
        if (dot) dot.style.background = '#f97373';
      } else {
        pill.classList.add('ready');
        span.innerHTML = `<strong>Rosters</strong> loaded`;
        if (dot) dot.style.background = '#22c55e';
      }
    }

    // ------------------------- CSV helpers ------------------------------------
    async function fetchCsvText() {
      let lastErr = null;
      for (const url of CSV_URLS) {
        try {
          const res = await fetch(url, { cache: 'no-store', mode: 'cors' });
          if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
          const txt = await res.text();
          return { txt, url };
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('CSV not reachable');
    }

    function parseCsvToRows(text) {
      text = String(text || '').replace(/^\uFEFF/, ''); // strip BOM
      const rows = [];
      let row = [], field = '', q = false;

      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (q) {
          if (c === '"') {
            if (text[i + 1] === '"') {
              field += '"';
              i++;
            } else {
              q = false;
            }
          } else {
            field += c;
          }
        } else {
          if (c === '"') {
            q = true;
          } else if (c === ',') {
            row.push(field);
            field = '';
          } else if (c === '\n') {
            row.push(field);
            rows.push(row);
            row = [];
            field = '';
          } else if (c !== '\r') {
            field += c;
          }
        }
      }
      row.push(field);
      rows.push(row);

      return rows.filter(r => r.length && r.some(x => x !== ''));
    }

    function rowsToObjectsWithDedupHeader(rows) {
      if (!rows.length) return [];
      const headerRaw = rows[0].map(h => String(h || '').trim());

      // Deduplicate header names: id, id_1, id_2, ...
      const nameCounts = {};
      const headers = headerRaw.map(h => {
        const base = h;
        const count = nameCounts[base] || 0;
        const name = count === 0 ? base : `${base}_${count}`;
        nameCounts[base] = count + 1;
        return name;
      });

      return rows.slice(1).map(r => {
        const o = {};
        headers.forEach((h, i) => {
          o[h] = r[i] === undefined ? '' : r[i];
        });
        return o;
      });
    }

    // --------------------- Roster grouping / rendering ------------------------
    function buildTeamsFromRows(objs) {
      const teamsMap = new Map();

      for (const row of objs) {
        const teamId = String(row.team_id || '').trim();
        const teamName = String(row.team_name || '').trim();
        if (!teamId && !teamName) continue;

        const key = teamId || teamName;
        if (!teamsMap.has(key)) {
          teamsMap.set(key, {
            teamId,
            teamName: teamName || teamId || 'Unknown',
            players: [],
          });
        }
        teamsMap.get(key).players.push(row);
      }

      const teams = Array.from(teamsMap.values());
      teams.sort((a, b) => {
        const nameA = (a.teamName || '').toLowerCase();
        const nameB = (b.teamName || '').toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        const idA = (a.teamId || '').toLowerCase();
        const idB = (b.teamId || '').toLowerCase();
        if (idA < idB) return -1;
        if (idA > idB) return 1;
        return 0;
      });

      // Sort players within team: position, depth
      for (const team of teams) {
        team.players.sort((p1, p2) => {
          const pos1 = String(p1.position || '').toUpperCase();
          const pos2 = String(p2.position || '').toUpperCase();
          if (pos1 < pos2) return -1;
          if (pos1 > pos2) return 1;

          const d1 = Number(p1.depth);
          const d2 = Number(p2.depth);
          if (Number.isFinite(d1) && Number.isFinite(d2)) {
            return d1 - d2;
          }
          return String(p1.first_name || '').localeCompare(p2.first_name || '');
        });
      }

      return teams;
    }

    function clearTeamsUI() {
      dom.teamsContainer.innerHTML = '';
    }

    function formatRating(v) {
      const n = Number(v);
      if (!Number.isFinite(n)) return '';
      return n.toFixed(1).replace(/\.0$/, '');
    }

    function renderTeams(teams, filterText) {
  clearTeamsUI();
  const filter = String(filterText || '').trim().toLowerCase();

  let visibleCount = 0;

  for (const team of teams) {
    const name = team.teamName || '';
    const id = team.teamId || '';
    const hay = `${name} ${id}`.toLowerCase();
    if (filter && !hay.includes(filter)) continue;

    visibleCount++;

    // Keep a working copy we can sort without mutating the source
    let currentRows = team.players.slice();

    // Card shell
    const section = document.createElement('details');
    section.className = 'team-card';
    if (!filter && visibleCount === 1) section.open = true;

    // Header
    const summary = document.createElement('summary');
    summary.className = 'team-header';

    const left = document.createElement('div');
    left.className = 'team-name-block';

    const nameSpan = document.createElement('div');
    nameSpan.className = 'team-name';
    nameSpan.textContent = name;

    const metaSpan = document.createElement('div');
    metaSpan.className = 'team-meta';
    const idLabel = id ? id : '—';
    metaSpan.textContent = `ID: ${idLabel} • ${team.players.length} players`;

    left.appendChild(nameSpan);
    left.appendChild(metaSpan);

    const right = document.createElement('div');
    right.className = 'roster-meta';
    right.textContent = 'Click to toggle roster';

    summary.appendChild(left);
    summary.appendChild(right);
    section.appendChild(summary);

    // Table wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'roster-table-wrapper';

    if (!team.players.length) {
      const p = document.createElement('p');
      p.className = 'empty-message';
      p.textContent = 'No players found for this team.';
      wrapper.appendChild(p);
    } else {
      // Build table
      const table = document.createElement('table');
      table.className = 'roster-table sortable';
      table.innerHTML = `
        <thead>
          <tr>
            <th data-key="position">Pos<span class="sort-icon"></span></th>
            <th data-key="depth"   >Depth<span class="sort-icon"></span></th>
            <th data-key="first_name">First<span class="sort-icon"></span></th>
            <th data-key="last_name" >Last<span class="sort-icon"></span></th>
            <th data-key="rating_overall">Ovr<span class="sort-icon"></span></th>
            <th data-key="rating_pos"    >Pos&nbsp;Rt<span class="sort-icon"></span></th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector('tbody');

      // Position order for "football sense" sorting when clicking Pos
      const POS_ORDER = { QB:0, RB:1, HB:1, FB:2, WR:3, TE:4, OL:5, DL:6, LB:7, DB:8, CB:8, S:8, K:9, P:10 };

      // Helpers for sorting
      const getters = {
        position: (r) => String(r.position || '').toUpperCase(),
        depth: (r) => Number(r.depth),
        first_name: (r) => String(r.first_name || ''),
        last_name:  (r) => String(r.last_name || ''),
        rating_overall: (r) => Number(r.rating_overall),
        rating_pos:     (r) => Number(r.rating_pos),
      };

      function cmpValues(a, b, key, dir) {
        // Special-case position using ranking table
        if (key === 'position') {
          const ra = POS_ORDER[a] ?? 999, rb = POS_ORDER[b] ?? 999;
          if (ra !== rb) return (ra - rb) * (dir === 'asc' ? 1 : -1);
          // tie-break alphabetically
          return a.localeCompare(b) * (dir === 'asc' ? 1 : -1);
        }

        const na = Number(a), nb = Number(b);
        const aNum = Number.isFinite(na), bNum = Number.isFinite(nb);

        if (aNum && bNum) {
          return (na - nb) * (dir === 'asc' ? 1 : -1);
        }
        // String compare fallback
        return String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }) * (dir === 'asc' ? 1 : -1);
      }

      function renderBody(list) {
        tbody.innerHTML = '';
        for (const row of list) {
          const tr = document.createElement('tr');
          const pos = String(row.position || '').toUpperCase();
          const depth = row.depth || '';
          const fn = row.first_name || '';
          const ln = row.last_name || '';
          const ovr = formatRating(row.rating_overall);
          const posRt = formatRating(row.rating_pos);

          tr.innerHTML = `
            <td>${pos}</td>
            <td>${depth}</td>
            <td>${fn}</td>
            <td>${ln}</td>
            <td>${ovr}</td>
            <td>${posRt}</td>
          `;
          tbody.appendChild(tr);
        }
      }

      // Initial body render (honors the pre-sort you already do in buildTeamsFromRows)
      renderBody(currentRows);

      // Click-to-select a row (subtle interactivity)
      tbody.addEventListener('click', (e) => {
        const tr = e.target.closest('tr');
        if (!tr) return;
        tbody.querySelectorAll('.row-selected').forEach(el => el.classList.remove('row-selected'));
        tr.classList.add('row-selected');
      });

      // Sorting state per table
      let sortKey = null;          // e.g., 'rating_overall'
      let sortDir = 'asc';         // 'asc' | 'desc'

      // Wire header clicks
      const ths = table.querySelectorAll('thead th');
      ths.forEach(th => th.setAttribute('aria-sort', 'none'));

      ths.forEach((th) => {
        th.addEventListener('click', () => {
          const key = th.dataset.key;
          if (!key || !getters[key]) return;

          // Toggle direction if same key; otherwise default asc
          sortDir = (sortKey === key && sortDir === 'asc') ? 'desc' : 'asc';
          sortKey = key;

          // Visual state
          ths.forEach(t => t.setAttribute('aria-sort', t === th ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'));

          // Sort a fresh copy of the team's rows (stable-ish by adding index)
          const withIdx = currentRows.map((r, i) => ({ r, i }));
          withIdx.sort((A, B) => {
            const a = getters[key](A.r);
            const b = getters[key](B.r);
            const primary = cmpValues(a, b, key, sortDir);
            if (primary !== 0) return primary;
            // stable tie-breaker: original index
            return (A.i - B.i) * (sortDir === 'asc' ? 1 : -1);
          });

          currentRows = withIdx.map(x => x.r);
          renderBody(currentRows);
        });
      });

      wrapper.appendChild(table);
    }

    section.appendChild(wrapper);
    dom.teamsContainer.appendChild(section);
  }

  if (visibleCount === 0) {
    const p = document.createElement('p');
    p.className = 'empty-message';
    p.textContent = filter
      ? 'No teams match this filter.'
      : 'No teams found in roster data.';
    dom.teamsContainer.appendChild(p);
  }

  return visibleCount;
}

    // ----------------------------- Main init ---------------------------------
    async function bootstrap() {
      setStatus('loading');
      dom.summaryText.textContent = 'Loading layer3_rosters.csv…';
      dom.sourceText.textContent = '';

      // Wire Simulation button right away, based on EFFECTIVE_ROSTER_URL
      if (dom.btnSim) {
        const simHref = `simulation.html?players=${encodeURIComponent(EFFECTIVE_ROSTER_URL)}`;
        dom.btnSim.href = simHref;
      }

      if (dom.btnBatch) {
        // You can change n=500 to any default you like; user can override via querystring
        const batchHref = `batch_sim.html?players=${encodeURIComponent(EFFECTIVE_ROSTER_URL)}&n=500`;
        dom.btnBatch.href = batchHref;
      }

      try {
        const { txt, url } = await fetchCsvText();
        const rows = parseCsvToRows(txt);
        const objs = rowsToObjectsWithDedupHeader(rows);
        const teams = buildTeamsFromRows(objs);

        dom.sourceText.textContent = `Source: ${url}`;
        dom.summaryText.textContent = `Loaded ${teams.length} teams and ${objs.length} player rows.`;

        setStatus('ready');
        const filterVal = dom.searchInput.value;
        const visible = renderTeams(teams, filterVal);

        dom.searchInput.addEventListener('input', () => {
          const val = dom.searchInput.value;
          const vCount = renderTeams(teams, val);
          dom.summaryText.textContent =
            val.trim()
              ? `Showing ${vCount} of ${teams.length} teams (filter: “${val.trim()}”).`
              : `Loaded ${teams.length} teams and ${objs.length} player rows.`;
        });

        dom.btnClear.addEventListener('click', () => {
          dom.searchInput.value = '';
          renderTeams(teams, '');
          dom.summaryText.textContent = `Loaded ${teams.length} teams and ${objs.length} player rows.`;
        });
      } catch (err) {
        console.error('Roster load error', err);
        setStatus('error', 'Failed to load rosters');
        dom.summaryText.textContent = 'Failed to load rosters.';
        dom.errorBox.style.display = 'block';
        dom.errorBox.textContent = `Error loading layer3_rosters.csv: ${err && err.message ? err.message : String(err)}`;
      }
    }

    bootstrap();
  </script>
</body>
</html>
